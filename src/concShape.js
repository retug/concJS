// This is the base polygon shape from which all analysis will be complete.
// There can be two types of constructors, one with a list of points and one with a given curve loop. A material is required for both conditions.
// If the point constructor is specified, a threejs shape will be created with straight lines connecting all the given points. This three js shape is saved as ConcShape.baseshape
// If the curve loop constructor is specified, a threejs shape will be created directly from the given curve loop. This three js shape is saved as ConcShape.baseshape
// There is an optional input for any holes
// There is a property within concShape called, mesh, which will store all of the internal meshing points and triangles generated by concAnlaysis.
// This class will also have a sub property called results. In results, we need to store angle and a list of triple data, [P, Mx, My]
// a separte class called "concAnalysis" will act on this base class and write in the results to the concShape.results properties.
// mesh is the base mesh, base shape with holes.
// FEMMesh is the deluany triangle mesh store base data in the X and Y coordinates. We will need to create U and V representations of this data
// for all Neutral axis angles.

import * as THREE from 'three';
import Delaunator from 'delaunator';
import { scene, controls, camera, renderer } from "./main.js"; 
import { rebarDia, setupRaycastingForResults  } from './threeJSscenefunctions.js';
import Plotly from 'plotly.js-dist-min';
//import Plotly from 'plotly.js';
// import * as SceneFunctions from './threeJSscenefunctions.js';


export class ConcShape {
    constructor(input, material, holes = []) {
        this.material = material;
        this.holes = holes;
        this.mesh = null; // base polygon with any holes
        this.FEMmesh = []; // ‚úÖ Stores the FEM triangular elements
        this.PMMXYresults = { }; // To store analysis results {angle: [P, Mx, My, MaxStrain]}
        this.PMMUVresults = { }; // To store analysis results {angle: [P, Mu, Mv, MaxStrain]}
        this.transformedFEMcentroids = {}; // ‚úÖ Initialize as an empty object

        this.basePolyXY = []; // ‚úÖ Stores exterior polygon points
        this.holesPolyXY = []; // ‚úÖ Stores hole points
        this.FEMarea = 0;  // ‚úÖ Total FEM area
        this.totalRebarArea = 0;
        this.centroidX = 0; // ‚úÖ X coordinate of centroid
        this.centroidY = 0; // ‚úÖ Y coordinate of centroid
        this.strainProfiles = {} //This will store all of the strain profiles for a given NA angle

        this.Pnmax = 0; //ACI 318-19 Table 22.4.2.1 Maxium Axial Strength

        this.rebarObjects = [] // ‚úÖ Initialize rebarObjects on creation


        // ‚úÖ Register this ConcShape in the global list
        window.allConcShapes.push(this);
        
        if (Array.isArray(input)) {
            // If input is an array of points
            this.basePoints = input;
            this.baseshape = this.createShapeFromPoints(input);
        } else if (input instanceof THREE.Shape) {
            // If input is a predefined curve loop (THREE.Shape)
            this.baseshape = input;
        } else {
            throw new Error("Invalid input: Must be an array of points or a THREE.Shape");
        }
        // ‚úÖ Apply existing holes (if any)
        this.holes.forEach(hole => this.baseshape.holes.push(hole));
    }

    // ‚úÖ Stores Three.js Points objects directly
    initializeRebarObjects(allSelectedRebar) {
        this.rebarObjects = allSelectedRebar; // Store Three.js Points directly
        // ‚úÖ Compute total rebar area
        this.totalRebarArea = this.rebarObjects.reduce((sum, rebar) => {
            let radius = rebarDia[rebar.rebarSize] / 2;  // Diameter to radius
            return sum + Math.PI * radius * radius; // Area of circle: œÄr¬≤
        }, 0);
    }


    addHole(holePoints) {
        const hole = this.createShapeFromPoints(holePoints);
        this.holes.push(hole);
        this.baseshape.holes.push(hole); // ‚úÖ Add hole to the main shape
        this.generateMesh();
    }

    createShapeFromPoints(points) {
        const shape = new THREE.Shape();
        if (points.length === 0) return shape;
        
        // Move to first point
        const firstPoint = new THREE.Vector2(points[0].x, points[0].y);
        shape.moveTo(firstPoint.x, firstPoint.y);
        
        // Connect remaining points with lines
        for (let i = 1; i < points.length; i++) {
            shape.lineTo(points[i].x, points[i].y);
        }
        
        // Close the shape
        shape.lineTo(firstPoint.x, firstPoint.y);
        
        // Add holes if provided
        this.holes.forEach(hole => shape.holes.push(hole));
        
        return shape;
    }

    generateMesh() {
        if (!this.baseshape) return;
        const geometry = new THREE.ShapeGeometry(this.baseshape);
        const meshMaterial = new THREE.MeshStandardMaterial({ color: 0xE5E5E5, transparent: true, opacity: 0.4});
        this.mesh = new THREE.Mesh(geometry, meshMaterial);
        this.mesh.userData.concShape = this; // ‚úÖ Store ConcShape instance in the mesh
    }

    generateFEMMesh() {
        if (!this.mesh) {
            console.error("Mesh does not exist for ConcShape.");
            return;
        }

        this.mesh.geometry.computeBoundingSphere();
        let center = [
            this.mesh.geometry.boundingSphere.center.x,
            this.mesh.geometry.boundingSphere.center.y
        ];
        let radius = this.mesh.geometry.boundingSphere.radius;

        // ‚úÖ Store exterior polygon and holes in class properties
        let baseShape = this.mesh.geometry.parameters.shapes;
        this.basePolyXY = baseShape.curves.map(curve => [curve.v1.x, curve.v1.y]); 
        this.holesPolyXY = baseShape.holes.map(hole => 
            hole.curves.map(curve => [curve.v1.x, curve.v1.y])
        );


        let minSize = parseFloat(document.getElementById("intSpa").value);
        let edgeSize = parseFloat(document.getElementById("edgeSpa").value);

        // Generate interior and boundary points
        let createdPnts = this.generateCirclePnts(center, radius, minSize);
        let [boundaryPnts, holePnts] = this.generateBoundaryPnts(this.basePolyXY, this.holesPolyXY, edgeSize);
        let generatedPnts = [];
        for (let circlePnt of createdPnts) {
            let TF = this.rayCasting(circlePnt);
            if (TF[0] === true) {
                generatedPnts.push(circlePnt);
            }
        }

        // Generate Delaunay triangulation points
        let XYlist = this.generateDelaunayPoints(boundaryPnts, holePnts, generatedPnts);
        let delaunay = Delaunator.from(XYlist);

        // Generate triangles and mesh elements
        let triangleXY = this.drawTriangles(delaunay.triangles, XYlist);
        let concElements = this.drawTrianglesThree(triangleXY);

        this.FEMmesh = concElements; // ‚úÖ Store generated FEM mesh
        console.log(this)
    }
     /** ‚úÖ Updated rayCasting to use stored class properties */
     rayCasting(point) {
        if (!this.basePolyXY.length) {
            console.error("rayCasting Error: basePolyXY is empty", this.basePolyXY);
            return [false, 0, 0];
        }

        let n = this.basePolyXY.length;
        let count = 0;
        let holeCount = 0;
        let [x, y] = point;

        for (let i = 0; i < n; ++i) {
            let x1 = this.basePolyXY[i][0], y1 = this.basePolyXY[i][1];
            let x2 = this.basePolyXY[(i + 1) % n][0], y2 = this.basePolyXY[(i + 1) % n][1];

            if (y < y1 !== y < y2 && x < ((x2 - x1) * (y - y1)) / (y2 - y1) + x1) {
                count += 1;
            }
        }

        for (let holePoly of this.holesPolyXY) {
            if (!holePoly.length) continue; // ‚úÖ Skip empty holes

            let nHole = holePoly.length;
            for (let i = 0; i < nHole; ++i) {
                let x1 = holePoly[i][0], y1 = holePoly[i][1];
                let x2 = holePoly[(i + 1) % nHole][0], y2 = holePoly[(i + 1) % nHole][1];

                if (y < y1 !== y < y2 && x < ((x2 - x1) * (y - y1)) / (y2 - y1) + x1) {
                    holeCount += 1;
                }
            }
        }

        return [(count + holeCount) % 2 !== 0, count, holeCount];
    }
    generateCirclePnts(center, radius, minSize) {
        let nCircles = Math.round(radius / minSize);
        let stepSize = radius / nCircles;
        let createdPnts = [[center[0], center[1]]];

        for (let i = 0; i < nCircles; i++) {
            let tempRadius = (i + 1) * stepSize;
            let totalLength = Math.PI * 2 * tempRadius;
            let nPoints = Math.round(totalLength / minSize);
            let thetaStep = (2 * Math.PI) / nPoints;

            for (let j = 0; j < nPoints; j++) {
                createdPnts.push([
                    Math.cos(thetaStep * j) * tempRadius + center[0],
                    Math.sin(thetaStep * j) * tempRadius + center[1]
                ]);
            }
        }
        return createdPnts;
    }
    generateBoundaryPnts(boundary, holes, minSize) {
        let boundaryPnts = this.generateEdgePnts(boundary, minSize);
        let holePnts = holes.map(hole => this.generateEdgePnts(hole, minSize)).flat();
        return [boundaryPnts, holePnts];
    }

    generateEdgePnts(edge, minSize) {
        let edgePnts = [];
        for (let i = 0; i < edge.length; i++) {
            let nextIndex = (i + 1) % edge.length;
            let [x1, y1] = edge[i];
            let [x2, y2] = edge[nextIndex];

            let length = Math.hypot(x2 - x1, y2 - y1);
            let nPoints = Math.round(length / minSize);
            let step = length / nPoints;
            let vector = [(x2 - x1) / length, (y2 - y1) / length];

            for (let j = 0; j < nPoints; j++) {
                edgePnts.push([x1 + vector[0] * j * step, y1 + vector[1] * j * step]);
            }
        }
        return edgePnts;
    }

    generateDelaunayPoints(boundaryPnts, holePnts, generatedPnts) {
        return [...boundaryPnts, ...holePnts, ...generatedPnts];
    }

    drawTriangles(triangles, XYlist) {
        return triangles.reduce((acc, _, i) => {
            if (i % 3 === 0) {
                acc.push([
                    XYlist[triangles[i]],
                    XYlist[triangles[i + 1]],
                    XYlist[triangles[i + 2]]
                ]);
            }
            return acc;
        }, []);
    }

    drawTrianglesThree(positionTri) {
        if (!scene || typeof scene.add !== "function") {
            console.error("Scene is not defined or is not a valid Three.js scene.");
            return [];
        }

        let concElements = [];
        this.FEMarea = 0; // ‚úÖ Reset total area
        this.centroidX = 0; // ‚úÖ Reset centroidX
        this.centroidY = 0; // ‚úÖ Reset centroidY

        for (let tri of positionTri) {
            let geometry = new THREE.BufferGeometry();
            let vertices = new Float32Array(tri.flatMap(([x, y]) => [x, y, 0]));
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setAttribute(
                "color",
                new THREE.BufferAttribute(new Float32Array(vertices.length), 3)
              );

            let material = new THREE.MeshBasicMaterial({ wireframe: true, vertexColors: true, side:THREE.DoubleSide });
            let mesh = new THREE.Mesh(geometry, material);

            // ‚úÖ Store a reference to the ConcShape in `userData`
            mesh.userData.concShape = this; // This stores the reference to the parent ConcShape

            mesh.area = Math.abs(
                (tri[0][0] * tri[1][1] + tri[1][0] * tri[2][1] + tri[2][0] * tri[0][1]) - 
                (tri[0][1] * tri[1][0] + tri[1][1] * tri[2][0] + tri[2][1] * tri[0][0])
            ) / 2;

            mesh.centroid = {
                x: (tri[0][0] + tri[1][0] + tri[2][0]) / 3,
                y: (tri[0][1] + tri[1][1] + tri[2][1]) / 3
            };

            // ‚úÖ Use stored basePolyXY and holesPolyXY for ray casting
            if (this.rayCasting([mesh.centroid.x, mesh.centroid.y])[0]) {
                scene.add(mesh);
                concElements.push(mesh);

                // ‚úÖ Update FEMarea and centroid
                this.FEMarea += mesh.area;
                this.centroidX += mesh.area * mesh.centroid.x;
                this.centroidY += mesh.area * mesh.centroid.y;
            }
            // Remove all objects from the scene that are not FEMmesh objects and keep all rebar objects
            scene.children = scene.children.filter(obj => this.FEMmesh.includes(obj) || obj.isRebar);

        }

        // ‚úÖ Compute final centroid
        if (this.FEMarea > 0) {
            this.centroidX /= this.FEMarea;
            this.centroidY /= this.FEMarea;
        } else {
            console.warn("Total FEM area is zero, cannot compute centroid.");
        }

        return concElements;
    }
    
    
    // FUTURE WORK FW, need to get rid of this, everything will be handled with default three.js elements. no need to make this and map indexes back and forth
    //This data will be orgainzed the following way. this.transformedFEMcentroids[45]; will return results at 45 degrees.
    // {
    //     45: {  // üîπ Angle (key)
    //         angle: 45,  // üîπ The transformation angle
    //         conc: [  // üîπ Transformed concrete FEM mesh centroids (U, V)
    //             { u: 1.5, v: 3.2 },
    //             { u: -2.1, v: 4.0 },
    //         ],
    //         rebar: [  // üîπ Transformed rebar centroids (U, V)
    //             { u: -3.2, v: 5.5 },
    //             { u: 4.8, v: -1.2 }
    //         ]
    //         centroidCoordinates : { "u": 0, "v": 0 }
    //     },

    //     90: {  // üîπ Another transformation at 90 degrees
    //         angle: 90,
    //         conc: [
    //             { u: 3.2, v: -1.5 },
    //             { u: 4.0, v: 2.1 },
    //         ],
    //         rebar: [
    //             { u: 5.5, v: 3.2 },
    //             { u: -1.2, v: -4.8 }
    //         ]
    //         centroidCoordinates : { u: 0, v: 0 }
    //     }
    // }

    // ‚úÖ Transforms coordinates at a given angle
    transformCoordinatesAtAngle(angle) {
        if (!this.FEMmesh || this.FEMmesh.length === 0) {
            console.error("‚ùå FEM mesh is empty, cannot transform coordinates.");
            return;
        }

        if (!this.transformedFEMcentroids) {
            this.transformedFEMcentroids = {};
        }

        const radians = (Math.PI / 180) * angle; // Convert degrees to radians
        const cosTheta = Math.cos(radians);
        const sinTheta = Math.sin(radians);

        // ‚úÖ Transform Concrete Centroids
        let transformedConcrete = this.FEMmesh.map(mesh => {
            let u = cosTheta * (mesh.centroid.x - this.centroidX) + sinTheta * (mesh.centroid.y - this.centroidY);
            let v = -sinTheta * (mesh.centroid.x - this.centroidX) + cosTheta * (mesh.centroid.y - this.centroidY);
            // ‚úÖ Store transformed coordinates inside the rebar object
            if (!mesh.transformedCentroid) mesh.transformedCentroid = {}; // Ensure dictionary exists
            mesh.transformedCentroid[angle] = {u, v}
            return { u, v };
        });

        // ‚úÖ Transform Rebar Centroids (Stored in `rebarObjects`)
        let transformedRebar = this.rebarObjects.map(rebar => {
            let rebarX = rebar.geometry.attributes.position.array[0]
            let rebarY = rebar.geometry.attributes.position.array[1]
 
            let u = cosTheta * (rebarX - this.centroidX) + sinTheta * (rebarY - this.centroidY);
            let v = -sinTheta * (rebarX - this.centroidX) + cosTheta * (rebarY - this.centroidY);
            
            // ‚úÖ Store transformed coordinates inside the rebar object
            if (!rebar.transformedCentroid) rebar.transformedCentroid = {}; // Ensure dictionary exists
            rebar.transformedCentroid[angle] = { u, v };

            return { u, v };
        });

        // ‚úÖ Transform Centroid Coordinates
        let transformedCentroid = {
            u: cosTheta * (this.centroidX - this.centroidX) + sinTheta * (this.centroidY - this.centroidY),
            v: -sinTheta * (this.centroidX - this.centroidX) + cosTheta * (this.centroidY - this.centroidY)
        };

        // ‚úÖ Store transformed data in the dictionary
        this.transformedFEMcentroids[angle] = {
            angle: angle,
            conc: transformedConcrete,         // ‚úÖ Store concrete mesh UV data
            // rebar: this.rebarObjects,          // ‚úÖ Store rebar objects with UV data
            centroidCoordinates: transformedCentroid  // ‚úÖ Store transformed centroid
        };

        // ‚úÖ Log the min/max U and V values
        const allUV = [...transformedConcrete, ...this.rebarObjects.map(rebar => rebar.transformedCentroid[angle])];
        const uVals = allUV.map(p => p.u);
        const vVals = allUV.map(p => p.v);

        this.populateAnalysisResults();
        

    }

    // Generate Strain Profiles for the PMM Analysis, returns [m and b] of y = mx +b linear strain equation
    generateStrains(angle) {
        // ‚úÖ Ensure the transformed FEM centroids exist for the given angle
        if (!this.transformedFEMcentroids[angle]) {
            console.error(`‚ùå No transformed FEM centroids found for angle ${angle}`);
            return;
        }

        // ‚úÖ Extract transformed rebar and concrete locations
        let concLocations = this.transformedFEMcentroids[angle].conc.map(p => p.v);  // Get only V coordinates

        // ‚úÖ Extract transformed rebar V coordinates
        let rebarLocations = this.rebarObjects
        .map(rebar => rebar.transformedCentroid[angle]?.v) // ‚úÖ Access transformed V values
        .filter(v => v !== undefined); // ‚úÖ Filter out undefined values

        if (!rebarLocations.length || !concLocations.length) {
            console.error("‚ùå Rebar or Concrete locations are empty. Cannot generate strain profiles.");
            return;
        }

        // ‚úÖ Find min/max V positions for rebar and concrete
        let rebarMax = Math.max(...rebarLocations);
        let rebarMin = Math.min(...rebarLocations);
        let concMax = Math.max(...concLocations);
        let concMin = Math.min(...concLocations);

        console.log(`üîπ Angle ${angle}¬∞:`);
        console.log(`   ‚úÖ Rebar Max: ${rebarMax}, Min: ${rebarMin}`);
        console.log(`   ‚úÖ Concrete Max: ${concMax}, Min: ${concMin}`);

        // ‚úÖ Define strain limits
        let epsilon_c = -0.003;  // Concrete crushing strain
        let epsilon_t = 0.025;   // Maximum tension strain of profile
        let steps = 25;          // Number of steps for profile generation

        // ‚úÖ Initialize strain profiles
        let strainProfileCtoT = [];
        let strainProfileTtoT = [];
        let strainProfileTtoC = [];
        let strainProfileCtoC = [];

        // ‚úÖ Compute slope steps
        let slopeStepCtoT = ((epsilon_t - epsilon_c) / (concMax - rebarMin)) / (steps - 1);
        let slopeStepTtoT = ((epsilon_c - epsilon_t) / (concMax - rebarMin)) / (steps - 1);
        let slopeStepTtoC = -((epsilon_c - epsilon_t) / (rebarMax - concMin)) / (steps - 1);
        let slopeStepCtoC = -((epsilon_c - epsilon_t) / (rebarMax - concMin)) / (steps - 1);

        // ‚úÖ Generate strain profiles
        for (let i = 0; i < steps; i++) {
            // ‚úÖ Compression to Tension (C to T)
            strainProfileCtoT.push([
                -i * slopeStepCtoT, 
                epsilon_c - (-i * slopeStepCtoT) * concMax
            ]);

            // ‚úÖ Tension Failure to Tension (T to T)
            strainProfileTtoT.push([
                -(epsilon_t - epsilon_c) / (concMax - rebarMin) - slopeStepTtoT * i,
                epsilon_t - (-(epsilon_t - epsilon_c) / (concMax - rebarMin) - slopeStepTtoT * i) * rebarMin
            ]);

            // ‚úÖ Tension to Compression (T to C)
            strainProfileTtoC.push([
                slopeStepTtoC * i,
                epsilon_t - (i * slopeStepTtoC) * rebarMax
            ]);

            // ‚úÖ Compression to Compression (C to C)
            strainProfileCtoC.push([
                -((epsilon_c - epsilon_t) / (rebarMax - concMin)) - slopeStepCtoC * i,
                epsilon_c - slopeStepCtoC * -(steps - 1 - i) * -concMin
            ]);
        }

        // ‚úÖ Combine all strain profiles
        let strainProfile = strainProfileCtoT.concat(strainProfileTtoT, strainProfileTtoC, strainProfileCtoC);

        console.log(`‚úÖ Generated strain profile for angle ${angle}:`, strainProfile);

        // ‚úÖ Store strain profile in the class dictionary
        if (!this.strainProfiles) {
            this.strainProfiles = {}; 
        }
        this.strainProfiles[angle] = strainProfile;

        return strainProfile;
    }

    // Function to convert Mu and Mv to Mx and My
    convertUVtoXY(angle, Mu, Mv) {
        let radians = (Math.PI / 180) * angle;
        let Mx = Mu * Math.sin(radians) - Mv * Math.cos(radians);
        let My = Mu * Math.cos(radians) + Mv * Math.sin(radians);
        return { Mx, My };
    }   


    //assumes a linear strain distribution
    strainFunction(m, x, b) {
        return m*x+b
    }
  
    // Given the angle, generate the associated P, Mu, Mv.
    generatePMM(angle) {
        if (!this.transformedFEMcentroids[angle]) {
            console.error(`‚ùå No transformed centroids found for angle ${angle}`);
            return;
        }
        
        if (!this.strainProfiles[angle]) {
            console.error(`‚ùå No strain profiles found for angle ${angle}`);
            return;
        }
    
    
        console.log(`üîπ Generating PMM for angle ${angle}¬∞...`);
    
        let totalAxialForceArray = []
        let totalMomentUArray = []
        let totalMomentVArray = []
        let totalMomentXArray = []
        let totalMomentYArray = []

        let totalPhiAxialForceArray = []
        let totalPhiMomentXArray = []
        let totalPhiMomentYArray = []

        


        // Retrieve centroid coordinates in U-V space
        let centroidU = this.transformedFEMcentroids[angle].centroidCoordinates.u;
        let centroidV = this.transformedFEMcentroids[angle].centroidCoordinates.v;

        // Get material properties
        let concMaterial = this.material;  // ‚úÖ Concrete material stored in class

        if (!this.PMMUVresults) {
            this.PMMUVresults = {};
        }
        if (!this.PMMXYresults) {
            this.PMMXYresults = {};
        }
        if (!this.PMMUVresults[angle]) {
            this.PMMUVresults[angle] = { P: [], Mu: [], Mv: [] };
        }
        if (!this.PMMXYresults[angle]) {
            this.PMMXYresults[angle] = { P: [], Mx: [], My: [], MaxRebarStrain: [], phiP: [], phiMx: [], phiMy: [] };
        }
    
        //looping through each stress strain profile
        for (var strainProfile of this.strainProfiles[angle]) {
            let concForce = 0
            let concMomentV = 0
            let concMomentU = 0
            let steelForce = 0
            let steelMomentV = 0
            let steelMomentU = 0
            let maxRebarStrain = -Infinity; // Track the maximum rebar strain
    
    
            for (let i = 0; i < this.FEMmesh.length; i++) {
                let concEle = this.FEMmesh[i]; // Get the concrete element
                let transformedConc = this.transformedFEMcentroids[angle].conc[i]; // Get the transformed coordinates
            
                if (!transformedConc) {
                    console.warn(`‚ö†Ô∏è Missing transformed centroid for concrete element at index ${i}`);
                    continue;
                }
            
                let concStrain = this.strainFunction(strainProfile[0], transformedConc.v, strainProfile[1]);
                let nodalConcForce = concMaterial.stress(concStrain) * concEle.area;
            
            
                concForce += nodalConcForce;
                concMomentV += nodalConcForce * (centroidV - transformedConc.v);
                concMomentU += nodalConcForce * (centroidU - transformedConc.u);
            }
            
            for (let rebar of this.rebarObjects) {
                //area times stress(strain)
                let steelMaterial = rebar.materialData; // ‚úÖ Retrieve steel material
                let transformedRebar = rebar.transformedCentroid[angle]; // ‚úÖ Get transformed U/V at angle
                if (!transformedRebar) {
                    console.warn(`‚ö†Ô∏è No transformed coordinates for rebar at angle ${angle}`);
                    continue;
                }
    
                let rebarStrain = this.strainFunction(strainProfile[0], transformedRebar.v, strainProfile[1]);
                maxRebarStrain = Math.max(maxRebarStrain, rebarStrain); // Track the max strain
                let nodalSteelForce = (Math.PI / 4) * rebarDia[rebar.rebarSize] ** 2 * steelMaterial.stress(rebarStrain);

                steelForce += nodalSteelForce
                steelMomentV += nodalSteelForce*(centroidV-transformedRebar.v)
                steelMomentU += nodalSteelForce*(centroidU-transformedRebar.u)
            }
            let resultForce = (steelForce + concForce)/1000;
            let Mu = (-steelMomentU - concMomentU) / 12 / 1000;
            let Mv = (-steelMomentV - concMomentV) / 12 / 1000;
            let { Mx, My } = this.convertUVtoXY(angle, Mu, Mv);

            

            let phi = this.calculatePhi("other", maxRebarStrain);


            let cappedP = Math.max(resultForce, this.Pnmax)
            let phiP = phi * cappedP
            let phiMx = phi * Mx
            let phiMy = phi * My

            totalAxialForceArray.push(resultForce);
            totalMomentUArray.push(Mu);
            totalMomentVArray.push(Mv);

            totalMomentXArray.push(Mx);
            totalMomentYArray.push(My);

            totalPhiAxialForceArray.push(phiP);
            totalPhiMomentXArray.push(phiMx);
            totalPhiMomentYArray.push(phiMy);

        }



        this.PMMUVresults[angle].P.push(totalAxialForceArray);
        this.PMMUVresults[angle].Mu.push(totalMomentUArray);
        this.PMMUVresults[angle].Mv.push(totalMomentVArray);
        this.PMMXYresults[angle].P.push(totalAxialForceArray);
        this.PMMXYresults[angle].Mx.push(totalMomentXArray);
        this.PMMXYresults[angle].My.push(totalMomentYArray);


        // ‚úÖ Store phi values
        this.PMMXYresults[angle].phiP.push(totalPhiAxialForceArray);
        this.PMMXYresults[angle].phiMx.push(totalPhiMomentXArray);
        this.PMMXYresults[angle].phiMy.push(totalPhiMomentYArray);
        console.log(this.PMMXYresults[angle])
    }
    
    //ACI 318-19 Table 21.2.2
    calculatePhi(type, maxRebarStrain) {
        if (type === "spiral") return; // ‚úÖ Do nothing if "spiral"
    
        let phi;
        if (maxRebarStrain < 0.00207) {
            phi = 0.65;
        } else if (maxRebarStrain >= 0.00507) {
            phi = 0.9;
        } else {
            phi = 0.65 + 0.25 * (maxRebarStrain - 0.00207) / 0.003;
        }
    
        return phi;
    }

    plotPMMResults() {
        if (!this.PMMXYresults || Object.keys(this.PMMXYresults).length === 0) {
            console.error("‚ùå No PMM XY results available to plot.");
            return;
        }
    
        let uniqueAngles = Object.keys(this.PMMXYresults).map(Number);
        let angleDropdown = document.getElementById("angleSelection");
        
        // ‚úÖ If dropdown doesn't exist yet, create it and populate
        if (!angleDropdown) {
            let resultsDiv = document.getElementById("results");
            resultsDiv.innerHTML = `
                <h3>3D PMM Interaction Diagram</h3>
                <label for="angleSelection">Select Bending Axis Angle:</label>
                <select id="angleSelection"></select>

                <label for="indexSelection">Select Strain Profile Index:</label>
                <select id="indexSelection"></select>

                <div id='pmPlot' style='width: 100%; height: 500px;'></div>
            `;
            this.populateAngleDropdown(uniqueAngles);
            
            angleDropdown = document.getElementById("angleSelection");
        }
    
        let selectedAngle = parseFloat(angleDropdown.value) || uniqueAngles[0];
        this.populateIndexDropdown(selectedAngle)
    
        let P_values = [], Mx_values = [], My_values = [];
        let phiP_values = [], phiMx_values = [], phiMy_values = [];
        let angles = [], strainProfileIndices = [];
    
        for (let angle in this.PMMXYresults) {
            let numPoints = this.PMMXYresults[angle].P.flat().length;
            P_values.push(...this.PMMXYresults[angle].P.flat());
            Mx_values.push(...this.PMMXYresults[angle].Mx.flat());
            My_values.push(...this.PMMXYresults[angle].My.flat());
    
            phiP_values.push(...this.PMMXYresults[angle].phiP.flat());
            phiMx_values.push(...this.PMMXYresults[angle].phiMx.flat());
            phiMy_values.push(...this.PMMXYresults[angle].phiMy.flat());
    
            angles.push(...Array(numPoints).fill(Number(angle)));
            strainProfileIndices.push(...Array.from({ length: numPoints }, (_, i) => i));
        }
    
        let colors = angles.map(angle => angle === selectedAngle ? "rgb(255, 100, 0)" : "rgb(200, 200, 200)");
        let symbolTypes = angles.map(angle => angle === selectedAngle ? "circle" : "cross");
    
        let originalTrace = {
            x: Mx_values, y: My_values, z: P_values,
            mode: "markers", type: "scatter3d",
            marker: { size: 6, color: colors, opacity: 0.8, symbol: symbolTypes },
            name: "Original PMM",
            hovertemplate: "P - %{z:.1f} (k)<br> Mx - %{x:.1f} (kip*ft)<br> My - %{y:.1f} (kip*ft)<br> Index - %{customdata}",
            customdata: strainProfileIndices
        };
    
        let reducedTrace = {
            x: phiMx_values, y: phiMy_values, z: phiP_values,
            mode: "markers", type: "scatter3d",
            marker: { size: 6, color: colors, opacity: 0.8, symbol: symbolTypes },
            name: "Reduced (œÜPMM)",
            hovertemplate: "œÜP - %{z:.1f} (k)<br> œÜMx - %{x:.1f} (kip*ft)<br> œÜMy - %{y:.1f} (kip*ft)<br> Index - %{customdata}",
            customdata: strainProfileIndices
        };
    
        let layout = {
            title: "3D P-M Interaction Diagram",
            scene: {
                xaxis: { title: "Mx (kip-ft)" },
                yaxis: { title: "My (kip-ft)" },
                zaxis: { title: "P (k)" },
                aspectmode: "cube"
            },
            margin: { l: 0, r: 0, b: 0, t: 50 }
        };
    
        let plotDiv = document.getElementById("pmPlot");
    
        // ‚úÖ If the plot already exists, just update it instead of redrawing
        if (plotDiv.data) {
            Plotly.react("pmPlot", [originalTrace, reducedTrace], layout);
        } else {
            Plotly.newPlot("pmPlot", [originalTrace, reducedTrace], layout);
        }
    
        // ‚úÖ Attach event listener only once
        if (!angleDropdown.dataset.listenerAdded) {
            angleDropdown.addEventListener("change", () => {
                this.updatePMMHighlight();
                this.resetHighlightedPoint(); // Reset previously highlighted point
                this.highlightSelectedPoint(window.selectedIndex || 0, newAngle); // ‚úÖ Highlight selected point
            });
            angleDropdown.dataset.listenerAdded = true;
        }

        let indexDropdown = document.getElementById("indexSelection");
    
        // ‚úÖ Ensure highlight updates initially
        this.updatePMMHighlight();
        // ‚úÖ Add Click Event Listener to Fire for Selected Angle Only
        document.getElementById("pmPlot").on('plotly_click', (data) => {
            let clickedIndex = data.points[0].customdata;
            let clickedAngle = parseFloat(angleDropdown.value);
    
            window.selectedIndex = clickedIndex;
            window.selectedAngle = clickedAngle;
            indexDropdown.value = clickedIndex; // Sync dropdown
    
            window.selectedConcShape.generate3dStressPlot(clickedAngle, selectedConcShape.strainProfiles[clickedAngle][clickedIndex]);
    
            setTimeout(() => {
                console.log("üîÑ Reinitializing raycasting after PMM selection...");
                setupRaycastingForResults(scene, camera, renderer);
            }, 100);
        });

        // ‚úÖ Add Event Listener for `indexSelection` dropdown
        if (!indexDropdown.dataset.listenerAdded) {
            indexDropdown.addEventListener("change", () => {
                let selectedIndex = parseInt(indexDropdown.value, 10);
                let selectedAngle = parseFloat(angleDropdown.value);

                window.selectedIndex = selectedIndex;
                window.selectedAngle = selectedAngle;

                console.log(`üìå Strain Profile Index Changed: Angle ${selectedAngle}, Index ${selectedIndex}`);

                // ‚úÖ Generate 3D stress plot based on new index
                window.selectedConcShape.generate3dStressPlot(selectedAngle, selectedConcShape.strainProfiles[selectedAngle][selectedIndex]);
                this.resetHighlightedPoint(); // Reset previously highlighted point
                this.highlightSelectedPoint(selectedIndex, selectedAngle); // ‚úÖ Highlight selected point

            });
            indexDropdown.dataset.listenerAdded = true;
        }
    }

    populateIndexDropdown(angle) {
        let indexDropdown = document.getElementById("indexSelection");
        indexDropdown.innerHTML = ""; // Clear previous options
    
        if (!this.PMMXYresults[angle]) return;
    
        let numProfiles = this.PMMXYresults[angle].P[0].length;
    
        for (let i = 0; i < numProfiles; i++) {
            let option = document.createElement("option");
            option.value = i;
            option.text = `Profile ${i}`;
            indexDropdown.appendChild(option);
        }
    
        indexDropdown.value = 0; // Default to first profile
    }

    updatePMMHighlight() {
        let selectedAngle = parseFloat(document.getElementById("angleSelection").value);
        console.log("YOUR SELECTED ANGLE IS", selectedAngle);
        this.generateTableResults(selectedAngle)
    
        let plotDiv = document.getElementById("pmPlot");
        if (!plotDiv || !plotDiv.data) return;
    
        // ‚úÖ Extract all angles corresponding to each PMM data point
        let allAngles = [];
        for (let angle in this.PMMXYresults) {
            let numPoints = this.PMMXYresults[angle].P.flat().length;
            allAngles.push(...Array(numPoints).fill(Number(angle))); // Repeat angle for each data point
        }
    
        let originalColors = plotDiv.data[0].marker.color; // Get existing colors
        let originalSymbols = plotDiv.data[0].marker.symbol; // Get existing symbols
    
        // ‚úÖ Highlight all points belonging to the selected angle
        let updatedColors = originalColors.map((_, i) =>
            allAngles[i] === selectedAngle ? "rgb(255, 100, 0)" : "rgb(200, 200, 200)"
        );
    
        let updatedSymbols = originalSymbols.map((_, i) =>
            allAngles[i] === selectedAngle ? "circle" : "cross"
        );
    
        Plotly.restyle("pmPlot", {
            "marker.color": [updatedColors],
            "marker.symbol": [updatedSymbols]
        });
    }
    
    

    populateAngleDropdown(angles) {
        let angleDropdown = document.getElementById("angleSelection");
        angleDropdown.innerHTML = ""; // Clear previous options
    
        angles.forEach(angle => {
            let option = document.createElement("option");
            option.value = angle;
            option.text = `${angle}¬∞`;
            angleDropdown.appendChild(option);
        });
    
        angleDropdown.value = angles[0]; // Default to first angle
    }

    // ‚úÖ Resets previously highlighted point to its default state
    resetHighlightedPoint() {
        let plotDiv = document.getElementById("pmPlot");
        if (!plotDiv || plotDiv.data.length < 3) return; // Ensure a highlighted point exists

        // Remove the last trace, which is the highlighted point
        Plotly.deleteTraces(plotDiv, plotDiv.data.length - 1);
    }

    // ‚úÖ Highlights the selected point in the 3D PMM plot
    highlightSelectedPoint(index, selectedAngle) {
        let plotDiv = document.getElementById("pmPlot");
        let selectedData = this.PMMXYresults[selectedAngle];

        if (!selectedData) {
            console.error(`‚ùå No PMM data found for angle ${selectedAngle}`);
            return;
        }

        let Mx_selected = selectedData.Mx.flat()[index];
        let My_selected = selectedData.My.flat()[index];
        let P_selected = selectedData.P.flat()[index];

        let newTrace = {
            x: [Mx_selected],
            y: [My_selected],
            z: [P_selected],
            mode: "markers",
            type: "scatter3d",
            marker: { size: 10, color: "rgb(255, 0, 0)", opacity: 1.0, symbol: "diamond" },
            name: "Selected Point",
            hovertemplate: "P - %{z:.1f} (k)<br> Mx - %{x:.1f} (kip*ft)<br> My - %{y:.1f} (kip*ft)<br>"
        };

        Plotly.addTraces(plotDiv, newTrace);
    }

    setupBendingAngles() {
        // for (let angle = 0; angle <= 180; angle += 15) {
        //     this.generatePMM(angle);
        // }
        this.plotPMMResults();
    }
    

    generate3dStressPlot(angle, strainProfile) {
        //this function will update the 3d scene, plotting the stress of each element in the scene.
        //given the angle and strainProfile, calculate the stress at the centroid of all concrete elemments given strain.
        // Then modify concrete FEMmesh z index to plot stress, times a factor say 2 (stress/2 for 4ksi concrete is 2 units of displacment.) apply this to all FEMmesh objects in the scene.
        // let positions = mesh.geometry.attributes.position.array, positions[i + 2] = zOffset; positions[i + 5] = zOffset; positions[i + 8] = zOffset;
        // do a similar process for all rebarObjects in the scene. offset the rebar point object by its stress with some factor say stress/5
        // Function to calculate stress based on strain profile
        // Function to calculate stress based on strain profile, U, and V values

        const concreteScaleFactor = 4; // Adjust as needed
        const rebarScaleFactor = 5; // Adjust as needed
        const arrowScaleFactor = 4;
        let minConcreteStress = Infinity, maxConcreteStress = -Infinity;
        let minRebarStress = Infinity, maxRebarStress = -Infinity;

        function calculateStress(element, strainProfile, angle, concreteMat) {
            let transformed = element.transformedCentroid[angle]; // Get transformed U/V at angle
            if (!transformed) {
                console.warn(`‚ö†Ô∏è No transformed coordinates for element at angle ${angle}`);
                return 0;
            }
            
            let strain = strainProfile[0] * transformed.v + strainProfile[1];
            if (element instanceof THREE.Mesh) {
                return concreteMat.stress(strain);
            }
            else {
                return element.materialData.stress(strain);
            }
        }
        //used to plot point at concrete stress location.
        function calculateRebarNormalizedStress(element, strainProfile, angle, concreteMat) {
            let transformed = element.transformedCentroid[angle]; // Get transformed U/V at angle
            if (!transformed) {
                console.warn(`‚ö†Ô∏è No transformed coordinates for element at angle ${angle}`);
                return 0;
            }
            let strain = strainProfile[0] * transformed.v + strainProfile[1];
            return concreteMat.stress(strain);
        }

        let minZ = Infinity, maxZ = -Infinity;

        // Iterate through all FEMmesh objects in the scene
        const concreteMat = this.material

        this.FEMmesh.forEach((object) => {
            if (!object.geometry || !object.geometry.attributes.position) return;

            let positions = object.geometry.attributes.position.array;
            let stress = calculateStress(object, strainProfile, angle, concreteMat);
            minConcreteStress = Math.min(minConcreteStress, stress);
            maxConcreteStress = Math.max(maxConcreteStress, stress);
            let zOffset = (stress / 4000) * concreteScaleFactor;

            for (let i = 2; i < positions.length; i += 9) {
                let newZ = zOffset;
                minZ = Math.min(minZ, newZ);
                maxZ = Math.max(maxZ, newZ);
            }
        });
        
        // Second pass to update position and apply colors
        this.FEMmesh.forEach((object) => {
            let positions = object.geometry.attributes.position.array;
            let colors = object.geometry.attributes.color.array;
            let stress = calculateStress(object, strainProfile, angle, concreteMat);
            let zOffset = (stress / 4000) * concreteScaleFactor;
        
            for (let i = 0; i < positions.length; i += 3) { // Loop through ALL vertices
                positions[i + 2] = zOffset; // Modify Z-coordinate
        
                let normalizedZ = (positions[i + 2] - minZ) / (maxZ - minZ);
        
                // Assign color per vertex
                colors[i] = 1 - normalizedZ;  // Red channel
                colors[i + 1] = 0;            // Green channel
                colors[i + 2] = normalizedZ;  // Blue channel
            }
        
            object.geometry.attributes.position.needsUpdate = true;
            object.geometry.attributes.color.needsUpdate = true;
            object.geometry.computeBoundingBox()
            object.geometry.computeBoundingSphere()
        });

        let minZrebar = Infinity, maxZrebar = -Infinity;

        this.rebarObjects.forEach((object) => {
            if (!object.geometry || !object.geometry.attributes.position) return;

            // let positions = object.geometry.attributes.position.array;

            let stress = calculateStress(object, strainProfile, angle, object.materialData);
            minRebarStress = Math.min(minRebarStress, stress);
            maxRebarStress = Math.max(maxRebarStress, stress);
            
            
            let zOffset = (stress / 60000) * rebarScaleFactor;
            let newZ = zOffset;
            minZrebar = Math.min(minZ, newZ);
            maxZrebar = Math.max(maxZ, newZ);
        });

        // ‚úÖ Remove existing arrows before adding new ones
        scene.children.filter(obj => obj.userData.isCustomArrow === true).forEach(arrow => scene.remove(arrow));


        // Second pass to update position and apply colors
        this.rebarObjects.forEach((object) => {
            // Get the position attribute
            let positionAttribute = object.geometry.getAttribute('position');

            // Access the underlying Float32Array
            let p = positionAttribute.array;

            //let's plot the point at the location of the concrete stress to allow the point to be in the same position.
            //the length of the arrow will be based on the actual rebar stress in the object
            // start point of arrow head
            let rebarNormalizestress  = calculateRebarNormalizedStress(object, strainProfile, angle, concreteMat);
            let zOffsetRebar = (rebarNormalizestress / 4000) * concreteScaleFactor;

            let stress = calculateStress(object, strainProfile, angle, object.materialData);
            // Update the z value of the first vertex
            p[2] = zOffsetRebar;
            // Mark the attribute as needing an update
            positionAttribute.needsUpdate = true;
            object.geometry.computeBoundingBox()
            object.geometry.computeBoundingSphere()

            // Normalize rebar stress for coloring
            let normalizedStress = Math.abs(stress) / 60000; // Normalize for color mapping
            normalizedStress = Math.min(normalizedStress, 1); // Ensure max value of 1

            // Assign colors
            let rebarColor = new THREE.Color();
            if (stress < 0) {
                // üî¥ **Compression: Fully Red if Normalized Stress = 1, otherwise Red-to-Purple**
                let red = 1.0;  // Always fully red
                let green = 0.0; // No green component
                let blue = normalizedStress === 1 ? 0.0 : normalizedStress * 0.8; // Fully red if 1, else red to purple

                rebarColor.setRGB(red, green, blue);
            } else {
                // üîµ **Tension: Fully Blue if Normalized Stress = 0, otherwise Blue-to-Green**
                let red = 0.0; // No red component
                let green = normalizedStress;  // Green increases with stress
                let blue = normalizedStress === 0 ? 1.0 : 1.0 - (normalizedStress * 0.5); // Fully blue at 0 stress

                rebarColor.setRGB(red, green, blue);
            }
            object.material.color = rebarColor;
            // ‚úÖ Set transparency to 50%
            object.material.transparent = true;
            object.material.opacity = 0.5;
            object.material.needsUpdate = true;

            // Create and add arrow
            let startX = p[0];
            let startY = p[1];
            let extrusionDepth = p[2];

            let arrowDirection = new THREE.Vector3(0, 0, stress < 0 ? -1 : 1); // Flip for compression
            let arrowLength = Math.abs(stress) / 60000 * arrowScaleFactor; // Scale by stress

            let start, end;
            if (stress < 0) {
                // üìå **Compression: Start in air, end at rebar**
                start = [startX, startY, extrusionDepth + arrowLength];
                end = [startX, startY, extrusionDepth];
            } else {
                // üìå **Tension: Start at rebar, extend outward**
                start = [startX, startY, extrusionDepth];
                end = [startX, startY, extrusionDepth + arrowLength];
            }
            // Call the new custom arrow function
            createCustomArrow(start, end, rebarColor.getHex(), 0.1, 0.3, stress);
            
        });

        function createCustomArrow(start, end, color, thickness = 0.1, coneSize = 0.3, stress) {
            const arrowGroup = new THREE.Group();
        
            // Convert start and end to Vector3
            const startVec = new THREE.Vector3(...start);
            const endVec = new THREE.Vector3(...end);
        
            // Compute direction and length
            const direction = new THREE.Vector3().subVectors(endVec, startVec);
            const length = direction.length();
            direction.normalize();
        
            // Create cylinder for the shaft
            const shaftGeometry = new THREE.CylinderGeometry(thickness, thickness, length - coneSize, 12);
            const shaftMaterial = new THREE.MeshBasicMaterial({ color: color });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
        
            // Align the shaft along the Z-axis
            shaft.position.set(0, 0, (length - coneSize) / 2);
            shaft.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction); // Align to direction
        
            // Create cone for the arrowhead
            const coneGeometry = new THREE.ConeGeometry(coneSize * 1.5, coneSize, 12);
            const coneMaterial = new THREE.MeshBasicMaterial({ color: color });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
        
            // Position the cone
            cone.position.set(0, 0, length - coneSize / 2);
        
            // Reverse cone direction if in compression (stress < 0)
            let coneDirection = direction.clone(); // Copy direction so shaft is not affected
            if (stress < 0) {
                coneDirection.negate(); // Flip only the cone direction
            }
        
            // Rotate the cone to align with direction
            cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), coneDirection);
        
            // Add shaft and cone to arrow group
            arrowGroup.add(shaft);
            arrowGroup.add(cone);
            //This is to filter and remove from the scene.
            arrowGroup.userData.isCustomArrow = true
        
            // Position the entire arrow
            arrowGroup.position.copy(startVec);
            arrowGroup.position.z += 0.5;  // ‚úÖ Move up by 0.5 units in the Z direction
            arrowGroup.lookAt(endVec);
        
            scene.add(arrowGroup);
            return arrowGroup;
        }

        // ‚úÖ Update the concShape class with new stress values
        minConcreteStress = minConcreteStress / 1000; // Convert to ksi
        maxConcreteStress = maxConcreteStress / 1000;
        minRebarStress = minRebarStress / 1000;
        maxRebarStress = maxRebarStress / 1000;

        console.log("Min/Max Concrete Stress:", minConcreteStress, maxConcreteStress);
        console.log("Min/Max Rebar Stress:", minRebarStress, maxRebarStress);

        // ‚úÖ Inject the updated color scale
        this.colorScaleHTML(minConcreteStress, maxConcreteStress, minRebarStress, maxRebarStress);
    }

    CalcPnmax(type) {
        if (type !== "other") {
            console.warn(`‚ö†Ô∏è Unsupported type "${type}" passed to CalcPnmax. No calculation performed.`);
            return;
        }
    
        console.log("üîπ Calculating Pnmax...");
    
        let concMat = this.material;  // Concrete compressive strength (psi)
        let fpc = concMat.stress(-0.003)
        console.log("your fpc is", fpc)
        let totalConcreteArea = this.FEMarea;  // Total section area (in¬≤)
        let totalSteelArea = 0;  // Initialize steel area sum
        let totalSteelForce = 0; // Initialize steel force sum
    
        // ‚úÖ Loop through each rebar object and sum up the steel area
        for (let rebar of this.rebarObjects) {
            //area times stress(strain)
            let steelMaterial = rebar.materialData; // ‚úÖ Retrieve steel material

            let rebarStrain = 0.005
            let nodalSteelForce = (Math.PI / 4) * rebarDia[rebar.rebarSize] ** 2 * steelMaterial.stress(rebarStrain);
            totalSteelForce -= nodalSteelForce
        }

        console.log("your rebar force is", totalSteelForce)
    
        // ‚úÖ Compute Po (Nominal Axial Capacity)
        let Po = 0.85 * fpc * (totalConcreteArea - totalSteelArea) + totalSteelForce;
    
        // ‚úÖ Store Pnmax in the class
        this.Pnmax = (0.8*Po) / 1000;  // Convert to kips (if fpc is in psi)
    
        console.log(`‚úÖ Pnmax Calculated: ${this.Pnmax.toFixed(2)} kips`);
    }

    colorScaleHTML(minConcreteStress, maxConcreteStress, minRebarStress, maxRebarStress) {
        let selectedPointProps = document.getElementById("selectedPointResultProps");
        if (!selectedPointProps) return;

        // ‚úÖ Retrieve the selected PMM results
        let selectedAngle = window.selectedAngle || 0;  // Ensure angle is defined
        let selectedIndex = window.selectedIndex || 0; // Ensure index is defined
        console.log("YOUR SELECTED INDEX IS", selectedIndex)
        window.selectedStrainProfileIndex = selectedIndex

        let P = this.PMMXYresults[selectedAngle]?.P[0]?.[selectedIndex] || 0;
        let Mx = this.PMMXYresults[selectedAngle]?.Mx[0]?.[selectedIndex] || 0;
        let My = this.PMMXYresults[selectedAngle]?.My[0]?.[selectedIndex] || 0;

        let phiP = this.PMMXYresults[selectedAngle]?.phiP[0]?.[selectedIndex] || 0;
        let phiMx = this.PMMXYresults[selectedAngle]?.phiMx[0]?.[selectedIndex] || 0;
        let phiMy = this.PMMXYresults[selectedAngle]?.phiMy[0]?.[selectedIndex] || 0;
    
        // ‚úÖ Generate color stops for concrete and rebar
        let concreteColors = this.generateColorScale(minConcreteStress, maxConcreteStress, this.getConcreteColor);
        let rebarColors = this.generateColorScale(minRebarStress, maxRebarStress, this.getRebarColor);
    
        selectedPointProps.innerHTML = `
            <div class="pmm-values p-3 bg-white shadow-md rounded-md">
                <h3 class="text-sm font-semibold text-center mb-2">Selected PMM Values</h3>
                <table class="w-auto mx-auto border border-gray-300 text-center text-xs rounded-md overflow-hidden">
                    <thead class="bg-gray-100 text-gray-600">
                        <tr>
                            <th class="py-1 px-2 border border-gray-300"></th>
                            <th class="py-1 px-2 border border-gray-300">Axial (k)</th>
                            <th class="py-1 px-2 border border-gray-300">Mx (k*ft)</th>
                            <th class="py-1 px-2 border border-gray-300">My (k*ft)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="bg-white hover:bg-gray-50">
                            <td class="py-1 px-2 font-medium border border-gray-300">Nominal</td>
                            <td class="py-1 px-2 border border-gray-300">${P.toFixed(2)}</td>
                            <td class="py-1 px-2 border border-gray-300">${Mx.toFixed(2)}</td>
                            <td class="py-1 px-2 border border-gray-300">${My.toFixed(2)}</td>
                        </tr>
                        <tr class="bg-gray-50 hover:bg-gray-100">
                            <td class="py-1 px-2 font-medium border border-gray-300">Capacity</td>
                            <td class="py-1 px-2 border border-gray-300">${phiP.toFixed(2)}</td>
                            <td class="py-1 px-2 border border-gray-300">${phiMx.toFixed(2)}</td>
                            <td class="py-1 px-2 border border-gray-300">${phiMy.toFixed(2)}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="stress-scale">
                <p><strong>Concrete Stress (ksi)</strong></p>
                <div class="color-bar" style="background: ${concreteColors};"></div>
                <div class="scale-labels">
                    <span>${minConcreteStress.toFixed(1)}</span> 
                    <span>${((minConcreteStress + maxConcreteStress) / 2).toFixed(1)}</span> 
                    <span>${maxConcreteStress.toFixed(1)}</span>
                </div>
            </div>
    
            <div class="stress-scale">
                <p><strong>Rebar Stress (ksi)</strong></p>
                <div class="color-bar" style="background: ${rebarColors};"></div>
                <div class="scale-labels">
                    <span>${minRebarStress.toFixed(1)}</span> 
                    <span>${((minRebarStress + maxRebarStress) / 2).toFixed(1)}</span> 
                    <span>${maxRebarStress.toFixed(1)}</span>
                </div>
            </div>
        `;
    }
    

    generateColorScale(min, max, colorFunction) {
        if (min === max) {
            return colorFunction(max, min, max); // Solid color when min == max
        }
        return `linear-gradient(to right, ${colorFunction(min, min, max)}, ${colorFunction((min + max) / 2, min, max)}, ${colorFunction(max, min, max)})`;
    }
    
    

    getConcreteColor(stress, minConcreteStress, maxConcreteStress) {
        let normalized = (stress - minConcreteStress) / (maxConcreteStress - minConcreteStress);
        return `rgb(${(1 - normalized) * 255}, 0, ${normalized * 255})`; // Red to Blue
    }
    
    
    getRebarColor(stress, minRebarStress, maxRebarStress) {
        let normalized = Math.abs(stress) / (maxRebarStress || 1);
    
        if (minRebarStress === maxRebarStress) {
            return stress < 0 ? "rgb(255, 0, 0)" : "rgb(0, 255, 0)"; // Solid red or green
        }
    
        if (stress < 0) {
            // üî¥ **Compression: Fully Red if Normalized = 1, otherwise Red-to-Purple**
            let red = 255;
            let green = 0;
            let blue = normalized === 1 ? 0 : normalized * 200; // Fully red if 1, else red to purple
            return `rgb(${red}, ${green}, ${blue})`;
        } else {
            // üîµ **Tension: Fully Blue if Normalized = 0, otherwise Blue-to-Green**
            let red = 0;
            let green = normalized * 255; // Green increases with stress
            let blue = normalized === 0 ? 255 : 255 - (normalized * 125); // Fully blue at 0 stress
            return `rgb(${red}, ${green}, ${blue})`;
        }
    }

    populateAnalysisResults() {
        let analysisResults = document.getElementById("analysisResults");
        let userInputProps = document.getElementById("userInputProps");

        if (!analysisResults) return;

        if (userInputProps) {
            userInputProps.innerHTML = "";
        }

    
        // ‚úÖ Ensure `this.FEMarea` and `this.centroidX` exist
        let FEMarea = this.FEMarea || 0;
        let centroidX = this.centroidX || 0;
        let centroidY = this.centroidY || 0;
        let rebarArea = this.totalRebarArea||0;
        let reinforcementRatio = (rebarArea / FEMarea) * 100; // Convert to percentage
        
    
        // ‚úÖ Inject content dynamically
        analysisResults.innerHTML = `
        <div class="pmm-values p-3 bg-white shadow-md rounded-md">
            <h3 class="text-sm font-semibold text-center mb-2">Concrete Shape Properties</h3>
            <table class="w-auto mx-auto border border-gray-300 text-center text-xs rounded-md overflow-hidden">
                <thead class="bg-gray-100 text-gray-600">
                    <tr>
                        <th class="py-1 px-2 border border-gray-300" title="Concrete Area (in¬≤)">Conc Area</th>
                        <th class="py-1 px-2 border border-gray-300" title="Rebar Area (in¬≤)">Stl Area</th>
                        <th class="py-1 px-2 border border-gray-300" title="Reinforcing Ratio (%)">œÅ (%)</th>
                        <th class="py-1 px-2 border border-gray-300" title="X Centriod of Shape (in)">X (in)</th>
                        <th class="py-1 px-2 border border-gray-300" title="Y Centriod of Shape (in)">Y (in)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="bg-white hover:bg-gray-50">
                        <td class="py-1 px-2 border border-gray-300">${FEMarea.toFixed(1)}</td>
                        <td class="py-1 px-2 border border-gray-300">${rebarArea.toFixed(2)}</td>
                        <td class="py-1 px-2 border border-gray-300">${reinforcementRatio.toFixed(2)}</td>
                        <td class="py-1 px-2 border border-gray-300">${centroidX.toFixed(1)}</td>
                        <td class="py-1 px-2 border border-gray-300">${centroidY.toFixed(1)}</td>
                    </tr>
                </tbody>
            </table>
        </div>
        `;
    }
    
    
    //Shift plus middle mouse button to rotate
    setupResultsControls(){
        console.log("Setting up results controls...");
        // Remove mouse interactions setup
        console.log(controls)
        if (typeof SceneFunctions !== 'undefined' && SceneFunctions.setupMouseInteractions) {
            delete SceneFunctions.setupMouseInteractions;
        }
        
        // Re-enable orbit controls rotation and panning
        if (typeof controls !== 'undefined') {
            controls.enableRotate = true;
            controls.enablePan = true;
            
            // Assign default controls
            // controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE; // Right mouse rotates
            controls.mouseButtons.MIDDLE = THREE.MOUSE.PAN;   // Middle mouse pans
    
            // Assign Shift + Middle Mouse Button to Rotate
            controls.keys = { SHIFT: THREE.MOUSE.ROTATE };
    
            console.log(controls);
        }

        // Modify .selectBox CSS to be invisible
        const style = document.createElement('style');
        style.innerHTML = `
            .selectBox {
                border: none !important;
                background-color: transparent !important;
                position: fixed !important;
            }
        `;
        document.head.appendChild(style);
    }

    generateTableResults(selectedAngle) {
        // Retrieve the PMM results arrays (extracting the first element)
        let P = this.PMMXYresults[selectedAngle]?.P?.[0] || [];
        let Mx = this.PMMXYresults[selectedAngle]?.Mx?.[0] || [];
        let My = this.PMMXYresults[selectedAngle]?.My?.[0] || [];
        let phiP = this.PMMXYresults[selectedAngle]?.phiP?.[0] || [];
        let phiMx = this.PMMXYresults[selectedAngle]?.phiMx?.[0] || [];
        let phiMy = this.PMMXYresults[selectedAngle]?.phiMy?.[0] || [];
    
        // Determine the number of rows (assumes all arrays have the same length)
        let rowCount = Math.max(P.length, Mx.length, My.length, phiP.length, phiMx.length, phiMy.length);
    
        // Construct table rows dynamically
        let rowsHTML = "";
        for (let i = 0; i < rowCount; i++) {
            rowsHTML += `
                <tr class="bg-white hover:bg-gray-50">
                    <td class="py-1 px-2 border border-gray-300">${(P[i] ?? 0).toFixed(2)}</td>
                    <td class="py-1 px-2 border border-gray-300">${(Mx[i] ?? 0).toFixed(2)}</td>
                    <td class="py-1 px-2 border border-gray-300">${(My[i] ?? 0).toFixed(2)}</td>
                    <td class="py-1 px-2 border border-gray-300">${(phiP[i] ?? 0).toFixed(2)}</td>
                    <td class="py-1 px-2 border border-gray-300">${(phiMx[i] ?? 0).toFixed(2)}</td>
                    <td class="py-1 px-2 border border-gray-300">${(phiMy[i] ?? 0).toFixed(2)}</td>
                </tr>
            `;
        }
    
        // Construct the full results table
        let tableHTML = `
            <div id="analysisResultsTable" class="pmm-values p-3 bg-white shadow-md rounded-md mt-4">
                <h3 class="text-sm font-semibold text-center mb-2">
                    Analysis Results - Bending Angle = ${selectedAngle}
                </h3>
                <div class="max-h-64 overflow-y-auto overflow-x-auto border border-gray-500 w-full">
                    <table class="w-auto mx-auto border border-gray-300 text-center text-xs rounded-md overflow-hidden">
                        <thead class="bg-gray-100 text-gray-600">
                            <tr>
                                <th class="py-1 px-2 border border-gray-300">Axial (k)</th>
                                <th class="py-1 px-2 border border-gray-300">Mx (k*ft)</th>
                                <th class="py-1 px-2 border border-gray-300">My (k*ft)</th>
                                <th class="py-1 px-2 border border-gray-300">œïP (k)</th>
                                <th class="py-1 px-2 border border-gray-300">œïMx (k*ft)</th>
                                <th class="py-1 px-2 border border-gray-300">œïMy (k*ft)</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rowsHTML}
                        </tbody>
                    </table>
                </div>
            </div>
        `;
    
        // Inject or replace the results table inside "materialsandShapes"
        let materialsAndShapesDiv = document.getElementById("materialsandShapes");
        let existingTable = document.getElementById("analysisResultsTable");


    
        if (existingTable) {
            // Replace the existing table if it exists
            existingTable.outerHTML = tableHTML;
        } else {
            let stressStrainChart = document.getElementById("stressStrainChart");
            if (stressStrainChart) {
                stressStrainChart.insertAdjacentHTML("afterend", tableHTML);
            } else {
                materialsAndShapesDiv.insertAdjacentHTML("beforeend", tableHTML);
            }
        }
    
        // Hide the ShapeButtons and square_rect_oval_shapes sections
        document.getElementById("ShapeButtons").style.display = "none";
        document.getElementById("square_rect_oval_shapes").style.display = "none";
    }

    
}

