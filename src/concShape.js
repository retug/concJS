// This is the base polygon shape from which all analysis will be complete.
// There can be two types of constructors, one with a list of points and one with a given curve loop. A material is required for both conditions.
// If the point constructor is specified, a threejs shape will be created with straight lines connecting all the given points. This three js shape is saved as ConcShape.baseshape
// If the curve loop constructor is specified, a threejs shape will be created directly from the given curve loop. This three js shape is saved as ConcShape.baseshape
// There is an optional input for any holes
// There is a property within concShape called, mesh, which will store all of the internal meshing points and triangles generated by concAnlaysis.
// This class will also have a sub property called results. In results, we need to store angle and a list of triple data, [P, Mx, My]
// a separte class called "concAnalysis" will act on this base class and write in the results to the concShape.results properties.
// mesh is the base mesh, base shape with holes.
// FEMMesh is the deluany triangle mesh store base data in the X and Y coordinates. We will need to create U and V representations of this data
// for all Neutral axis angles.

import * as THREE from 'three';
import Delaunator from 'delaunator';
import { scene } from "./main.js"; 

export class ConcShape {
    constructor(input, material, holes = []) {
        this.material = material;
        this.holes = holes;
        this.mesh = null; // base polygon with any holes
        this.FEMmesh = []; // ✅ Stores the FEM triangular elements
        this.results = { angle: 0, data: [] }; // To store analysis results [P, Mx, My]
        this.basePolyXY = []; // ✅ Stores exterior polygon points
        this.holesPolyXY = []; // ✅ Stores hole points
        
        if (Array.isArray(input)) {
            // If input is an array of points
            this.basePoints = input;
            this.baseshape = this.createShapeFromPoints(input);
        } else if (input instanceof THREE.Shape) {
            // If input is a predefined curve loop (THREE.Shape)
            this.baseshape = input;
        } else {
            throw new Error("Invalid input: Must be an array of points or a THREE.Shape");
        }
        // ✅ Apply existing holes (if any)
        this.holes.forEach(hole => this.baseshape.holes.push(hole));
    }

    addHole(holePoints) {
        const hole = this.createShapeFromPoints(holePoints);
        this.holes.push(hole);
        this.baseshape.holes.push(hole); // ✅ Add hole to the main shape
        this.generateMesh();
    }

    createShapeFromPoints(points) {
        const shape = new THREE.Shape();
        if (points.length === 0) return shape;
        
        // Move to first point
        const firstPoint = new THREE.Vector2(points[0].x, points[0].y);
        shape.moveTo(firstPoint.x, firstPoint.y);
        
        // Connect remaining points with lines
        for (let i = 1; i < points.length; i++) {
            shape.lineTo(points[i].x, points[i].y);
        }
        
        // Close the shape
        shape.lineTo(firstPoint.x, firstPoint.y);
        
        // Add holes if provided
        this.holes.forEach(hole => shape.holes.push(hole));
        
        return shape;
    }

    generateMesh() {
        if (!this.baseshape) return;
        const geometry = new THREE.ShapeGeometry(this.baseshape);
        const meshMaterial = new THREE.MeshStandardMaterial({ color: 0xE5E5E5, transparent: true, opacity: 0.4 });
        this.mesh = new THREE.Mesh(geometry, meshMaterial);
        this.mesh.userData.concShape = this; // ✅ Store ConcShape instance in the mesh
    }

    generateFEMMesh() {
        if (!this.mesh) {
            console.error("Mesh does not exist for ConcShape.");
            return;
        }

        this.mesh.geometry.computeBoundingSphere();
        let center = [
            this.mesh.geometry.boundingSphere.center.x,
            this.mesh.geometry.boundingSphere.center.y
        ];
        let radius = this.mesh.geometry.boundingSphere.radius;

        // ✅ Store exterior polygon and holes in class properties
        let baseShape = this.mesh.geometry.parameters.shapes;
        this.basePolyXY = baseShape.curves.map(curve => [curve.v1.x, curve.v1.y]); 
        this.holesPolyXY = baseShape.holes.map(hole => 
            hole.curves.map(curve => [curve.v1.x, curve.v1.y])
        );

        console.log('Stored basePolyXY:', this.basePolyXY);
        console.log('Stored holesPolyXY:', this.holesPolyXY);

        let minSize = parseFloat(document.getElementById("intSpa").value);
        let edgeSize = parseFloat(document.getElementById("edgeSpa").value);

        // Generate interior and boundary points
        let createdPnts = this.generateCirclePnts(center, radius, minSize);
        console.log('your created points are ', createdPnts)
        let [boundaryPnts, holePnts] = this.generateBoundaryPnts(this.basePolyXY, this.holesPolyXY, edgeSize);
        console.log('your boundary points are ', boundaryPnts)
        let generatedPnts = [];
        for (let circlePnt of createdPnts) {
            console.log('your current point is', circlePnt)
            let TF = this.rayCasting(circlePnt);
            if (TF[0] === true) {
                generatedPnts.push(circlePnt);
            }
        }

        // Generate Delaunay triangulation points
        let XYlist = this.generateDelaunayPoints(boundaryPnts, holePnts, generatedPnts);
        let delaunay = Delaunator.from(XYlist);

        // Generate triangles and mesh elements
        let triangleXY = this.drawTriangles(delaunay.triangles, XYlist);
        let concElements = this.drawTrianglesThree(triangleXY);

        this.FEMmesh = concElements; // ✅ Store generated FEM mesh
    }
     /** ✅ Updated rayCasting to use stored class properties */
     rayCasting(point) {
        if (!this.basePolyXY.length) {
            console.error("rayCasting Error: basePolyXY is empty", this.basePolyXY);
            return [false, 0, 0];
        }

        let n = this.basePolyXY.length;
        let count = 0;
        let holeCount = 0;
        let [x, y] = point;

        for (let i = 0; i < n; ++i) {
            let x1 = this.basePolyXY[i][0], y1 = this.basePolyXY[i][1];
            let x2 = this.basePolyXY[(i + 1) % n][0], y2 = this.basePolyXY[(i + 1) % n][1];

            if (y < y1 !== y < y2 && x < ((x2 - x1) * (y - y1)) / (y2 - y1) + x1) {
                count += 1;
            }
        }

        for (let holePoly of this.holesPolyXY) {
            if (!holePoly.length) continue; // ✅ Skip empty holes

            let nHole = holePoly.length;
            for (let i = 0; i < nHole; ++i) {
                let x1 = holePoly[i][0], y1 = holePoly[i][1];
                let x2 = holePoly[(i + 1) % nHole][0], y2 = holePoly[(i + 1) % nHole][1];

                if (y < y1 !== y < y2 && x < ((x2 - x1) * (y - y1)) / (y2 - y1) + x1) {
                    holeCount += 1;
                }
            }
        }

        return [(count + holeCount) % 2 !== 0, count, holeCount];
    }
    generateCirclePnts(center, radius, minSize) {
        let nCircles = Math.round(radius / minSize);
        let stepSize = radius / nCircles;
        let createdPnts = [[center[0], center[1]]];

        for (let i = 0; i < nCircles; i++) {
            let tempRadius = (i + 1) * stepSize;
            let totalLength = Math.PI * 2 * tempRadius;
            let nPoints = Math.round(totalLength / minSize);
            let thetaStep = (2 * Math.PI) / nPoints;

            for (let j = 0; j < nPoints; j++) {
                createdPnts.push([
                    Math.cos(thetaStep * j) * tempRadius + center[0],
                    Math.sin(thetaStep * j) * tempRadius + center[1]
                ]);
            }
        }
        return createdPnts;
    }
    generateBoundaryPnts(boundary, holes, minSize) {
        let boundaryPnts = this.generateEdgePnts(boundary, minSize);
        let holePnts = holes.map(hole => this.generateEdgePnts(hole, minSize)).flat();
        return [boundaryPnts, holePnts];
    }

    generateEdgePnts(edge, minSize) {
        let edgePnts = [];
        for (let i = 0; i < edge.length; i++) {
            let nextIndex = (i + 1) % edge.length;
            let [x1, y1] = edge[i];
            let [x2, y2] = edge[nextIndex];

            let length = Math.hypot(x2 - x1, y2 - y1);
            let nPoints = Math.round(length / minSize);
            let step = length / nPoints;
            let vector = [(x2 - x1) / length, (y2 - y1) / length];

            for (let j = 0; j < nPoints; j++) {
                edgePnts.push([x1 + vector[0] * j * step, y1 + vector[1] * j * step]);
            }
        }
        return edgePnts;
    }

    generateDelaunayPoints(boundaryPnts, holePnts, generatedPnts) {
        return [...boundaryPnts, ...holePnts, ...generatedPnts];
    }

    drawTriangles(triangles, XYlist) {
        return triangles.reduce((acc, _, i) => {
            if (i % 3 === 0) {
                acc.push([
                    XYlist[triangles[i]],
                    XYlist[triangles[i + 1]],
                    XYlist[triangles[i + 2]]
                ]);
            }
            return acc;
        }, []);
    }

    drawTrianglesThree(positionTri) {
        if (!scene || typeof scene.add !== "function") {
            console.error("Scene is not defined or is not a valid Three.js scene.");
            return [];
        }
        let concElements = [];
        let area = 0;
        let concCentroidX = 0, concCentroidY = 0;

        for (let tri of positionTri) {
            let geometry = new THREE.BufferGeometry();
            let vertices = new Float32Array(tri.flatMap(([x, y]) => [x, y, 0]));
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

            let material = new THREE.MeshStandardMaterial({ wireframe: true });
            let mesh = new THREE.Mesh(geometry, material);
            mesh.area = Math.abs(
                (tri[0][0] * tri[1][1] + tri[1][0] * tri[2][1] + tri[2][0] * tri[0][1]) - 
                (tri[0][1] * tri[1][0] + tri[1][1] * tri[2][0] + tri[2][1] * tri[0][0])
            ) / 2;

            mesh.centroid = {
                x: (tri[0][0] + tri[1][0] + tri[2][0]) / 3,
                y: (tri[0][1] + tri[1][1] + tri[2][1]) / 3
            };

            // ✅ Use stored basePolyXY and holesPolyXY for ray casting
            if (this.rayCasting([mesh.centroid.x, mesh.centroid.y])[0]) {
                scene.add(mesh);
                concElements.push(mesh);
                area += mesh.area;
                concCentroidX += mesh.area * mesh.centroid.x;
                concCentroidY += mesh.area * mesh.centroid.y;
            }
        }

        return [concElements, [concCentroidX / area, concCentroidY / area]];
    }
}
