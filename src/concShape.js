// This is the base polygon shape from which all analysis will be complete.
// There can be two types of constructors, one with a list of points and one with a given curve loop. A material is required for both conditions.
// If the point constructor is specified, a threejs shape will be created with straight lines connecting all the given points. This three js shape is saved as ConcShape.baseshape
// If the curve loop constructor is specified, a threejs shape will be created directly from the given curve loop. This three js shape is saved as ConcShape.baseshape
// There is an optional input for any holes
// There is a property within concShape called, mesh, which will store all of the internal meshing points and triangles generated by concAnlaysis.
// This class will also have a sub property called results. In results, we need to store angle and a list of triple data, [P, Mx, My]
// a separte class called "concAnalysis" will act on this base class and write in the results to the concShape.results properties.
// mesh is the base mesh, base shape with holes.
// FEMMesh is the deluany triangle mesh store base data in the X and Y coordinates. We will need to create U and V representations of this data
// for all Neutral axis angles.

import * as THREE from 'three';
import Delaunator from 'delaunator';
import { scene, controls } from "./main.js"; 
import { rebarDia } from './threeJSscenefunctions.js';
import Plotly from 'plotly.js-dist-min';


export class ConcShape {
    constructor(input, material, holes = []) {
        this.material = material;
        this.holes = holes;
        this.mesh = null; // base polygon with any holes
        this.FEMmesh = []; // ‚úÖ Stores the FEM triangular elements
        this.PMMXYresults = { }; // To store analysis results {angle: [P, Mx, My]}
        this.PMMUVresults = { }; // To store analysis results {angle: [P, Mu, Mv]}
        this.transformedFEMcentroids = {}; // ‚úÖ Initialize as an empty object
        

        this.basePolyXY = []; // ‚úÖ Stores exterior polygon points
        this.holesPolyXY = []; // ‚úÖ Stores hole points
        this.FEMarea = 0;  // ‚úÖ Total FEM area
        this.centroidX = 0; // ‚úÖ X coordinate of centroid
        this.centroidY = 0; // ‚úÖ Y coordinate of centroid
        this.strainProfiles = {} //This will store all of the strain profiles for a given NA angle

        this.rebarObjects = [] // ‚úÖ Initialize rebarObjects on creation
        
        if (Array.isArray(input)) {
            // If input is an array of points
            this.basePoints = input;
            this.baseshape = this.createShapeFromPoints(input);
        } else if (input instanceof THREE.Shape) {
            // If input is a predefined curve loop (THREE.Shape)
            this.baseshape = input;
        } else {
            throw new Error("Invalid input: Must be an array of points or a THREE.Shape");
        }
        // ‚úÖ Apply existing holes (if any)
        this.holes.forEach(hole => this.baseshape.holes.push(hole));
    }

    // ‚úÖ Stores Three.js Points objects directly
    initializeRebarObjects(allSelectedRebar) {
        this.rebarObjects = allSelectedRebar; // Store Three.js Points directly
    }


    addHole(holePoints) {
        const hole = this.createShapeFromPoints(holePoints);
        this.holes.push(hole);
        this.baseshape.holes.push(hole); // ‚úÖ Add hole to the main shape
        this.generateMesh();
    }

    createShapeFromPoints(points) {
        const shape = new THREE.Shape();
        if (points.length === 0) return shape;
        
        // Move to first point
        const firstPoint = new THREE.Vector2(points[0].x, points[0].y);
        shape.moveTo(firstPoint.x, firstPoint.y);
        
        // Connect remaining points with lines
        for (let i = 1; i < points.length; i++) {
            shape.lineTo(points[i].x, points[i].y);
        }
        
        // Close the shape
        shape.lineTo(firstPoint.x, firstPoint.y);
        
        // Add holes if provided
        this.holes.forEach(hole => shape.holes.push(hole));
        
        return shape;
    }

    generateMesh() {
        if (!this.baseshape) return;
        const geometry = new THREE.ShapeGeometry(this.baseshape);
        const meshMaterial = new THREE.MeshStandardMaterial({ color: 0xE5E5E5, transparent: true, opacity: 0.4});
        this.mesh = new THREE.Mesh(geometry, meshMaterial);
        this.mesh.userData.concShape = this; // ‚úÖ Store ConcShape instance in the mesh
    }

    generateFEMMesh() {
        if (!this.mesh) {
            console.error("Mesh does not exist for ConcShape.");
            return;
        }

        this.mesh.geometry.computeBoundingSphere();
        let center = [
            this.mesh.geometry.boundingSphere.center.x,
            this.mesh.geometry.boundingSphere.center.y
        ];
        let radius = this.mesh.geometry.boundingSphere.radius;

        // ‚úÖ Store exterior polygon and holes in class properties
        let baseShape = this.mesh.geometry.parameters.shapes;
        this.basePolyXY = baseShape.curves.map(curve => [curve.v1.x, curve.v1.y]); 
        this.holesPolyXY = baseShape.holes.map(hole => 
            hole.curves.map(curve => [curve.v1.x, curve.v1.y])
        );


        let minSize = parseFloat(document.getElementById("intSpa").value);
        let edgeSize = parseFloat(document.getElementById("edgeSpa").value);

        // Generate interior and boundary points
        let createdPnts = this.generateCirclePnts(center, radius, minSize);
        let [boundaryPnts, holePnts] = this.generateBoundaryPnts(this.basePolyXY, this.holesPolyXY, edgeSize);
        let generatedPnts = [];
        for (let circlePnt of createdPnts) {
            let TF = this.rayCasting(circlePnt);
            if (TF[0] === true) {
                generatedPnts.push(circlePnt);
            }
        }

        // Generate Delaunay triangulation points
        let XYlist = this.generateDelaunayPoints(boundaryPnts, holePnts, generatedPnts);
        let delaunay = Delaunator.from(XYlist);

        // Generate triangles and mesh elements
        let triangleXY = this.drawTriangles(delaunay.triangles, XYlist);
        let concElements = this.drawTrianglesThree(triangleXY);

        this.FEMmesh = concElements; // ‚úÖ Store generated FEM mesh
        console.log(this)
    }
     /** ‚úÖ Updated rayCasting to use stored class properties */
     rayCasting(point) {
        if (!this.basePolyXY.length) {
            console.error("rayCasting Error: basePolyXY is empty", this.basePolyXY);
            return [false, 0, 0];
        }

        let n = this.basePolyXY.length;
        let count = 0;
        let holeCount = 0;
        let [x, y] = point;

        for (let i = 0; i < n; ++i) {
            let x1 = this.basePolyXY[i][0], y1 = this.basePolyXY[i][1];
            let x2 = this.basePolyXY[(i + 1) % n][0], y2 = this.basePolyXY[(i + 1) % n][1];

            if (y < y1 !== y < y2 && x < ((x2 - x1) * (y - y1)) / (y2 - y1) + x1) {
                count += 1;
            }
        }

        for (let holePoly of this.holesPolyXY) {
            if (!holePoly.length) continue; // ‚úÖ Skip empty holes

            let nHole = holePoly.length;
            for (let i = 0; i < nHole; ++i) {
                let x1 = holePoly[i][0], y1 = holePoly[i][1];
                let x2 = holePoly[(i + 1) % nHole][0], y2 = holePoly[(i + 1) % nHole][1];

                if (y < y1 !== y < y2 && x < ((x2 - x1) * (y - y1)) / (y2 - y1) + x1) {
                    holeCount += 1;
                }
            }
        }

        return [(count + holeCount) % 2 !== 0, count, holeCount];
    }
    generateCirclePnts(center, radius, minSize) {
        let nCircles = Math.round(radius / minSize);
        let stepSize = radius / nCircles;
        let createdPnts = [[center[0], center[1]]];

        for (let i = 0; i < nCircles; i++) {
            let tempRadius = (i + 1) * stepSize;
            let totalLength = Math.PI * 2 * tempRadius;
            let nPoints = Math.round(totalLength / minSize);
            let thetaStep = (2 * Math.PI) / nPoints;

            for (let j = 0; j < nPoints; j++) {
                createdPnts.push([
                    Math.cos(thetaStep * j) * tempRadius + center[0],
                    Math.sin(thetaStep * j) * tempRadius + center[1]
                ]);
            }
        }
        return createdPnts;
    }
    generateBoundaryPnts(boundary, holes, minSize) {
        let boundaryPnts = this.generateEdgePnts(boundary, minSize);
        let holePnts = holes.map(hole => this.generateEdgePnts(hole, minSize)).flat();
        return [boundaryPnts, holePnts];
    }

    generateEdgePnts(edge, minSize) {
        let edgePnts = [];
        for (let i = 0; i < edge.length; i++) {
            let nextIndex = (i + 1) % edge.length;
            let [x1, y1] = edge[i];
            let [x2, y2] = edge[nextIndex];

            let length = Math.hypot(x2 - x1, y2 - y1);
            let nPoints = Math.round(length / minSize);
            let step = length / nPoints;
            let vector = [(x2 - x1) / length, (y2 - y1) / length];

            for (let j = 0; j < nPoints; j++) {
                edgePnts.push([x1 + vector[0] * j * step, y1 + vector[1] * j * step]);
            }
        }
        return edgePnts;
    }

    generateDelaunayPoints(boundaryPnts, holePnts, generatedPnts) {
        return [...boundaryPnts, ...holePnts, ...generatedPnts];
    }

    drawTriangles(triangles, XYlist) {
        return triangles.reduce((acc, _, i) => {
            if (i % 3 === 0) {
                acc.push([
                    XYlist[triangles[i]],
                    XYlist[triangles[i + 1]],
                    XYlist[triangles[i + 2]]
                ]);
            }
            return acc;
        }, []);
    }

    drawTrianglesThree(positionTri) {
        if (!scene || typeof scene.add !== "function") {
            console.error("Scene is not defined or is not a valid Three.js scene.");
            return [];
        }

        let concElements = [];
        this.FEMarea = 0; // ‚úÖ Reset total area
        this.centroidX = 0; // ‚úÖ Reset centroidX
        this.centroidY = 0; // ‚úÖ Reset centroidY

        for (let tri of positionTri) {
            let geometry = new THREE.BufferGeometry();
            let vertices = new Float32Array(tri.flatMap(([x, y]) => [x, y, 0]));
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setAttribute(
                "color",
                new THREE.BufferAttribute(new Float32Array(vertices.length), 3)
              );

            let material = new THREE.MeshBasicMaterial({ wireframe: true, vertexColors: true });
            let mesh = new THREE.Mesh(geometry, material);
            mesh.area = Math.abs(
                (tri[0][0] * tri[1][1] + tri[1][0] * tri[2][1] + tri[2][0] * tri[0][1]) - 
                (tri[0][1] * tri[1][0] + tri[1][1] * tri[2][0] + tri[2][1] * tri[0][0])
            ) / 2;

            mesh.centroid = {
                x: (tri[0][0] + tri[1][0] + tri[2][0]) / 3,
                y: (tri[0][1] + tri[1][1] + tri[2][1]) / 3
            };

            // ‚úÖ Use stored basePolyXY and holesPolyXY for ray casting
            if (this.rayCasting([mesh.centroid.x, mesh.centroid.y])[0]) {
                scene.add(mesh);
                concElements.push(mesh);

                // ‚úÖ Update FEMarea and centroid
                this.FEMarea += mesh.area;
                this.centroidX += mesh.area * mesh.centroid.x;
                this.centroidY += mesh.area * mesh.centroid.y;
            }
            // Remove all objects from the scene that are not FEMmesh objects
            scene.children = scene.children.filter(obj => this.FEMmesh.includes(obj) || obj.isRebar);

        }

        // ‚úÖ Compute final centroid
        if (this.FEMarea > 0) {
            this.centroidX /= this.FEMarea;
            this.centroidY /= this.FEMarea;
        } else {
            console.warn("Total FEM area is zero, cannot compute centroid.");
        }

        return concElements;
    }
    
    
    // FUTURE WORK FW, need to get rid of this, everything will be handled with default three.js elements. no need to make this and map indexes back and forth
    //This data will be orgainzed the following way. this.transformedFEMcentroids[45]; will return results at 45 degrees.
    // {
    //     45: {  // üîπ Angle (key)
    //         angle: 45,  // üîπ The transformation angle
    //         conc: [  // üîπ Transformed concrete FEM mesh centroids (U, V)
    //             { u: 1.5, v: 3.2 },
    //             { u: -2.1, v: 4.0 },
    //         ],
    //         rebar: [  // üîπ Transformed rebar centroids (U, V)
    //             { u: -3.2, v: 5.5 },
    //             { u: 4.8, v: -1.2 }
    //         ]
    //         centroidCoordinates : { "u": 0, "v": 0 }
    //     },

    //     90: {  // üîπ Another transformation at 90 degrees
    //         angle: 90,
    //         conc: [
    //             { u: 3.2, v: -1.5 },
    //             { u: 4.0, v: 2.1 },
    //         ],
    //         rebar: [
    //             { u: 5.5, v: 3.2 },
    //             { u: -1.2, v: -4.8 }
    //         ]
    //         centroidCoordinates : { u: 0, v: 0 }
    //     }
    // }

    // ‚úÖ Transforms coordinates at a given angle
    transformCoordinatesAtAngle(angle) {
        if (!this.FEMmesh || this.FEMmesh.length === 0) {
            console.error("‚ùå FEM mesh is empty, cannot transform coordinates.");
            return;
        }

        if (!this.transformedFEMcentroids) {
            this.transformedFEMcentroids = {};
        }

        const radians = (Math.PI / 180) * angle; // Convert degrees to radians
        const cosTheta = Math.cos(radians);
        const sinTheta = Math.sin(radians);

        // ‚úÖ Transform Concrete Centroids
        let transformedConcrete = this.FEMmesh.map(mesh => {
            let u = cosTheta * (mesh.centroid.x - this.centroidX) + sinTheta * (mesh.centroid.y - this.centroidY);
            let v = -sinTheta * (mesh.centroid.x - this.centroidX) + cosTheta * (mesh.centroid.y - this.centroidY);
            // ‚úÖ Store transformed coordinates inside the rebar object
            if (!mesh.transformedCentroid) mesh.transformedCentroid = {}; // Ensure dictionary exists
            mesh.transformedCentroid[angle] = {u, v}
            return { u, v };
        });

        // ‚úÖ Transform Rebar Centroids (Stored in `rebarObjects`)
        let transformedRebar = this.rebarObjects.map(rebar => {
            let rebarX = rebar.geometry.attributes.position.array[0]
            let rebarY = rebar.geometry.attributes.position.array[1]
 
            let u = cosTheta * (rebarX - this.centroidX) + sinTheta * (rebarY - this.centroidY);
            let v = -sinTheta * (rebarX - this.centroidX) + cosTheta * (rebarY - this.centroidY);
            
            // ‚úÖ Store transformed coordinates inside the rebar object
            if (!rebar.transformedCentroid) rebar.transformedCentroid = {}; // Ensure dictionary exists
            rebar.transformedCentroid[angle] = { u, v };

            return { u, v };
        });

        // ‚úÖ Transform Centroid Coordinates
        let transformedCentroid = {
            u: cosTheta * (this.centroidX - this.centroidX) + sinTheta * (this.centroidY - this.centroidY),
            v: -sinTheta * (this.centroidX - this.centroidX) + cosTheta * (this.centroidY - this.centroidY)
        };

        // ‚úÖ Store transformed data in the dictionary
        this.transformedFEMcentroids[angle] = {
            angle: angle,
            conc: transformedConcrete,         // ‚úÖ Store concrete mesh UV data
            // rebar: this.rebarObjects,          // ‚úÖ Store rebar objects with UV data
            centroidCoordinates: transformedCentroid  // ‚úÖ Store transformed centroid
        };

        // ‚úÖ Log the min/max U and V values
        const allUV = [...transformedConcrete, ...this.rebarObjects.map(rebar => rebar.transformedCentroid[angle])];
        const uVals = allUV.map(p => p.u);
        const vVals = allUV.map(p => p.v);

    }

    // Generate Strain Profiles for the PMM Analysis, returns [m and b] of y = mx +b linear strain equation
    generateStrains(angle) {
        // ‚úÖ Ensure the transformed FEM centroids exist for the given angle
        if (!this.transformedFEMcentroids[angle]) {
            console.error(`‚ùå No transformed FEM centroids found for angle ${angle}`);
            return;
        }

        // ‚úÖ Extract transformed rebar and concrete locations
        let concLocations = this.transformedFEMcentroids[angle].conc.map(p => p.v);  // Get only V coordinates

        // ‚úÖ Extract transformed rebar V coordinates
        let rebarLocations = this.rebarObjects
        .map(rebar => rebar.transformedCentroid[angle]?.v) // ‚úÖ Access transformed V values
        .filter(v => v !== undefined); // ‚úÖ Filter out undefined values

        if (!rebarLocations.length || !concLocations.length) {
            console.error("‚ùå Rebar or Concrete locations are empty. Cannot generate strain profiles.");
            return;
        }

        // ‚úÖ Find min/max V positions for rebar and concrete
        let rebarMax = Math.max(...rebarLocations);
        let rebarMin = Math.min(...rebarLocations);
        let concMax = Math.max(...concLocations);
        let concMin = Math.min(...concLocations);

        console.log(`üîπ Angle ${angle}¬∞:`);
        console.log(`   ‚úÖ Rebar Max: ${rebarMax}, Min: ${rebarMin}`);
        console.log(`   ‚úÖ Concrete Max: ${concMax}, Min: ${concMin}`);

        // ‚úÖ Define strain limits
        let epsilon_c = -0.003;  // Concrete crushing strain
        let epsilon_t = 0.025;   // Maximum tension strain
        let steps = 25;          // Number of steps for profile generation

        // ‚úÖ Initialize strain profiles
        let strainProfileCtoT = [];
        let strainProfileTtoT = [];
        let strainProfileTtoC = [];
        let strainProfileCtoC = [];

        // ‚úÖ Compute slope steps
        let slopeStepCtoT = ((epsilon_t - epsilon_c) / (concMax - rebarMin)) / (steps - 1);
        let slopeStepTtoT = ((epsilon_c - epsilon_t) / (concMax - rebarMin)) / (steps - 1);
        let slopeStepTtoC = -((epsilon_c - epsilon_t) / (rebarMax - concMin)) / (steps - 1);
        let slopeStepCtoC = -((epsilon_c - epsilon_t) / (rebarMax - concMin)) / (steps - 1);

        // ‚úÖ Generate strain profiles
        for (let i = 0; i < steps; i++) {
            // ‚úÖ Compression to Tension (C to T)
            strainProfileCtoT.push([
                -i * slopeStepCtoT, 
                epsilon_c - (-i * slopeStepCtoT) * concMax
            ]);

            // ‚úÖ Tension Failure to Tension (T to T)
            strainProfileTtoT.push([
                -(epsilon_t - epsilon_c) / (concMax - rebarMin) - slopeStepTtoT * i,
                epsilon_t - (-(epsilon_t - epsilon_c) / (concMax - rebarMin) - slopeStepTtoT * i) * rebarMin
            ]);

            // ‚úÖ Tension to Compression (T to C)
            strainProfileTtoC.push([
                slopeStepTtoC * i,
                epsilon_t - (i * slopeStepTtoC) * rebarMax
            ]);

            // ‚úÖ Compression to Compression (C to C)
            strainProfileCtoC.push([
                -((epsilon_c - epsilon_t) / (rebarMax - concMin)) - slopeStepCtoC * i,
                epsilon_c - slopeStepCtoC * -(steps - 1 - i) * -concMin
            ]);
        }

        // ‚úÖ Combine all strain profiles
        let strainProfile = strainProfileCtoT.concat(strainProfileTtoT, strainProfileTtoC, strainProfileCtoC);

        console.log(`‚úÖ Generated strain profile for angle ${angle}:`, strainProfile);

        // ‚úÖ Store strain profile in the class dictionary
        if (!this.strainProfiles) {
            this.strainProfiles = {}; 
        }
        this.strainProfiles[angle] = strainProfile;

        return strainProfile;
    }

    // Function to convert Mu and Mv to Mx and My
    convertUVtoXY(angle, Mu, Mv) {
        let radians = (Math.PI / 180) * angle;
        let Mx = Mu * Math.cos(radians) - Mv * Math.sin(radians);
        let My = Mu * Math.sin(radians) + Mv * Math.cos(radians);
        return { Mx, My };
    }   


    //assumes a linear strain distribution
    strainFunction(m, x, b) {
        return m*x+b
    }
  
    // Given the angle, generate the associated P, Mu, Mv.
    generatePMM(angle) {
        if (!this.transformedFEMcentroids[angle]) {
            console.error(`‚ùå No transformed centroids found for angle ${angle}`);
            return;
        }
        
        if (!this.strainProfiles[angle]) {
            console.error(`‚ùå No strain profiles found for angle ${angle}`);
            return;
        }
    
    
        console.log(`üîπ Generating PMM for angle ${angle}¬∞...`);
    
        let totalAxialForceArray = []
        let totalMomentUArray = []
        let totalMomentVArray = []
        let totalMomentXArray = []
        let totalMomentYArray = []


        // Retrieve centroid coordinates in U-V space
        let centroidU = this.transformedFEMcentroids[angle].centroidCoordinates.u;
        let centroidV = this.transformedFEMcentroids[angle].centroidCoordinates.v;

        // Get material properties
        let concMaterial = this.material;  // ‚úÖ Concrete material stored in class

        if (!this.PMMUVresults) {
            this.PMMUVresults = {};
        }
        if (!this.PMMXYresults) {
            this.PMMXYresults = {};
        }
        if (!this.PMMUVresults[angle]) {
            this.PMMUVresults[angle] = { P: [], Mu: [], Mv: [] };
        }
        if (!this.PMMXYresults[angle]) {
            this.PMMXYresults[angle] = { P: [], Mx: [], My: [] };
        }
    
        //looping through each stress strain profile
        for (var strainProfile of this.strainProfiles[angle]) {
            let concForce = 0
            let concMomentV = 0
            let concMomentU = 0
            let steelForce = 0
            let steelMomentV = 0
            let steelMomentU = 0
    
    
            for (let i = 0; i < this.FEMmesh.length; i++) {
                let concEle = this.FEMmesh[i]; // Get the concrete element
                let transformedConc = this.transformedFEMcentroids[angle].conc[i]; // Get the transformed coordinates
            
                if (!transformedConc) {
                    console.warn(`‚ö†Ô∏è Missing transformed centroid for concrete element at index ${i}`);
                    continue;
                }
            
                let concStrain = this.strainFunction(strainProfile[0], transformedConc.v, strainProfile[1]);
                let nodalConcForce = concMaterial.stress(concStrain) * concEle.area;
            
            
                concForce += nodalConcForce;
                concMomentV += nodalConcForce * (centroidV - transformedConc.v);
                concMomentU += nodalConcForce * (centroidU - transformedConc.u);
            }
            
            for (let rebar of this.rebarObjects) {
                //area times stress(strain)
                let steelMaterial = rebar.materialData; // ‚úÖ Retrieve steel material
                let transformedRebar = rebar.transformedCentroid[angle]; // ‚úÖ Get transformed U/V at angle
                if (!transformedRebar) {
                    console.warn(`‚ö†Ô∏è No transformed coordinates for rebar at angle ${angle}`);
                    continue;
                }
    
                let rebarStrain = this.strainFunction(strainProfile[0], transformedRebar.v, strainProfile[1]);
                let nodalSteelForce = (Math.PI / 4) * rebarDia[rebar.rebarSize] ** 2 * steelMaterial.stress(rebarStrain);

                steelForce += nodalSteelForce
                steelMomentV += nodalSteelForce*(centroidV-transformedRebar.v)
                steelMomentU += nodalSteelForce*(centroidU-transformedRebar.u)
            }
            let resultForce = (steelForce + concForce)/1000;
            let Mu = (-steelMomentU - concMomentU) / 12;
            let Mv = (-steelMomentV - concMomentV) / 12;
            let { Mx, My } = this.convertUVtoXY(angle, Mu, Mv);

            totalAxialForceArray.push(resultForce);
            totalMomentUArray.push(Mu);
            totalMomentVArray.push(Mv);
            totalMomentXArray.push(Mx);
            totalMomentYArray.push(My);
        }

        this.PMMUVresults[angle].P.push(totalAxialForceArray);
        this.PMMUVresults[angle].Mu.push(totalMomentUArray);
        this.PMMUVresults[angle].Mv.push(totalMomentVArray);
        this.PMMXYresults[angle].P.push(totalAxialForceArray);
        this.PMMXYresults[angle].Mx.push(totalMomentXArray);
        this.PMMXYresults[angle].My.push(totalMomentYArray);
    }
    

    // Modify the plot function to format hover tooltips
    plotPMMResults() {
        if (!this.PMMXYresults || Object.keys(this.PMMXYresults).length === 0) {
            console.error("‚ùå No PMM XY results available to plot.");
            return;
        }

        let P_values = [];
        let Mx_values = [];
        let My_values = [];
        let angles = [];

        for (let angle in this.PMMXYresults) {
            P_values.push(...this.PMMXYresults[angle].P.flat());
            Mx_values.push(...this.PMMXYresults[angle].Mx.flat());
            My_values.push(...this.PMMXYresults[angle].My.flat());
            angles.push(...Array(this.PMMXYresults[angle].P.flat().length).fill(Number(angle)));
        }

        let scatterTrace = {
            x: Mx_values,
            y: My_values,
            z: P_values,
            mode: "markers",
            type: "scatter3d",
            marker: { size: 5, color: angles, colorscale: "Viridis", opacity: 0.8 },
            name: "PMM Data",
            hovertemplate: "P - %{z:.1f} (k)<br>" +
                        "Mx - %{x:.1f} (kip*ft)<br>" +
                        "My - %{y:.1f} (kip*ft)"
        };

        let layout = {
            title: "3D P-M Interaction Diagram",
            scene: {
                xaxis: { title: "Mx (kip-ft)" },
                yaxis: { title: "My (kip-ft)" },
                zaxis: { title: "P (k)" },
                aspectmode: "cube"
            },
            margin: { l: 0, r: 0, b: 0, t: 50 }
        };
        let resultsDiv = document.getElementById("results");
        resultsDiv.innerHTML = "<h3>3D PMM Interaction Diagram</h3><div id='pmPlot' style='width: 100%; height: 500px;'></div>";
        Plotly.newPlot("pmPlot", [scatterTrace], layout);
    }

    generate3dStressPlot(angle, strainProfile) {
        //this function will update the 3d scene, plotting the stress of each element in the scene.
        //given the angle and strainProfile, calculate the stress at the centroid of all concrete elemments given strain.
        // Then modify concrete FEMmesh z index to plot stress, times a factor say 2 (stress/2 for 4ksi concrete is 2 units of displacment.) apply this to all FEMmesh objects in the scene.
        // let positions = mesh.geometry.attributes.position.array, positions[i + 2] = zOffset; positions[i + 5] = zOffset; positions[i + 8] = zOffset;
        // do a similar process for all rebarObjects in the scene. offset the rebar point object by its stress with some factor say stress/5
        // Function to calculate stress based on strain profile
        // Function to calculate stress based on strain profile, U, and V values

        const concreteScaleFactor = 4; // Adjust as needed
        const rebarScaleFactor = 5; // Adjust as needed
        const arrowScaleFactor = 4;

        function calculateStress(element, strainProfile, angle, concreteMat) {
            let transformed = element.transformedCentroid[angle]; // Get transformed U/V at angle
            if (!transformed) {
                console.warn(`‚ö†Ô∏è No transformed coordinates for element at angle ${angle}`);
                return 0;
            }
            
            let strain = strainProfile[0] * transformed.v + strainProfile[1];
            if (element instanceof THREE.Mesh) {
                return concreteMat.stress(strain);
            }
            else {
                return element.materialData.stress(strain);
            }
        }
        //used to plot point at concrete stress location.
        function calculateRebarNormalizedStress(element, strainProfile, angle, concreteMat) {
            let transformed = element.transformedCentroid[angle]; // Get transformed U/V at angle
            if (!transformed) {
                console.warn(`‚ö†Ô∏è No transformed coordinates for element at angle ${angle}`);
                return 0;
            }
            let strain = strainProfile[0] * transformed.v + strainProfile[1];
            return concreteMat.stress(strain);
        }

        let minZ = Infinity, maxZ = -Infinity;

        // Iterate through all FEMmesh objects in the scene
        const concreteMat = this.material

        this.FEMmesh.forEach((object) => {
            if (!object.geometry || !object.geometry.attributes.position) return;

            let positions = object.geometry.attributes.position.array;
            let stress = calculateStress(object, strainProfile, angle, concreteMat);
            let zOffset = (stress / 4000) * concreteScaleFactor;

            for (let i = 2; i < positions.length; i += 9) {
                let newZ = positions[i] + zOffset;
                minZ = Math.min(minZ, newZ);
                maxZ = Math.max(maxZ, newZ);
            }
        });
        
        // Second pass to update position and apply colors
        this.FEMmesh.forEach((object) => {
            let positions = object.geometry.attributes.position.array;
            let colors = object.geometry.attributes.color.array;
            let stress = calculateStress(object, strainProfile, angle, concreteMat);
            let zOffset = (stress / 4000) * concreteScaleFactor;
        
            for (let i = 0; i < positions.length; i += 3) { // Loop through ALL vertices
                positions[i + 2] += zOffset; // Modify Z-coordinate
        
                let normalizedZ = (positions[i + 2] - minZ) / (maxZ - minZ);
        
                // Assign color per vertex
                colors[i] = 1 - normalizedZ;  // Red channel
                colors[i + 1] = 0;            // Green channel
                colors[i + 2] = normalizedZ;  // Blue channel
            }
        
            object.geometry.attributes.position.needsUpdate = true;
            object.geometry.attributes.color.needsUpdate = true;
        });

        let minZrebar = Infinity, maxZrebar = -Infinity;

        this.rebarObjects.forEach((object) => {
            if (!object.geometry || !object.geometry.attributes.position) return;

            // let positions = object.geometry.attributes.position.array;

            let stress = calculateStress(object, strainProfile, angle, object.materialData);
            
            
            let zOffset = (stress / 60000) * rebarScaleFactor;
            let newZ = zOffset;
            minZrebar = Math.min(minZ, newZ);
            maxZrebar = Math.max(maxZ, newZ);
        });

        // Second pass to update position and apply colors
        this.rebarObjects.forEach((object) => {
            // Get the position attribute
            let positionAttribute = object.geometry.getAttribute('position');

            // Access the underlying Float32Array
            let p = positionAttribute.array;

            //let's plot the point at the location of the concrete stress to allow the point to be in the same position.
            //the length of the arrow will be based on the actual rebar stress in the object
            // start point of arrow head
            let rebarNormalizestress  = calculateRebarNormalizedStress(object, strainProfile, angle, concreteMat);
            let zOffsetRebar = (rebarNormalizestress / 4000) * concreteScaleFactor;

            let stress = calculateStress(object, strainProfile, angle, object.materialData);
            // Update the z value of the first vertex
            p[2] = zOffsetRebar;
            // Mark the attribute as needing an update
            positionAttribute.needsUpdate = true;

            // Normalize rebar stress for coloring
            let normalizedStress = Math.abs(stress) / 60000; // Normalize for color mapping
            normalizedStress = Math.min(normalizedStress, 1); // Ensure max value of 1

            // Assign colors
            let rebarColor = new THREE.Color();
            if (stress < 0) {
                // üî¥ **Compression: Fully Red if Normalized Stress = 1, otherwise Red-to-Purple**
                let red = 1.0;  // Always fully red
                let green = 0.0; // No green component
                let blue = normalizedStress === 1 ? 0.0 : normalizedStress * 0.8; // Fully red if 1, else red to purple

                rebarColor.setRGB(red, green, blue);
            } else {
                // üîµ **Tension: Fully Blue if Normalized Stress = 0, otherwise Blue-to-Green**
                let red = 0.0; // No red component
                let green = normalizedStress;  // Green increases with stress
                let blue = normalizedStress === 0 ? 1.0 : 1.0 - (normalizedStress * 0.5); // Fully blue at 0 stress

                rebarColor.setRGB(red, green, blue);
            }
            object.material.color = rebarColor;

            // Create and add arrow
            let startX = p[0];
            let startY = p[1];
            let extrusionDepth = p[2];

            let arrowDirection = new THREE.Vector3(0, 0, stress < 0 ? -1 : 1); // Flip for compression
            let arrowLength = Math.abs(stress) / 60000 * arrowScaleFactor; // Scale by stress

            let start, end;
            if (stress < 0) {
                // üìå **Compression: Start in air, end at rebar**
                start = [startX, startY, extrusionDepth + arrowLength];
                end = [startX, startY, extrusionDepth];
            } else {
                // üìå **Tension: Start at rebar, extend outward**
                start = [startX, startY, extrusionDepth];
                end = [startX, startY, extrusionDepth + arrowLength];
            }

            // Call the new custom arrow function
            createCustomArrow(start, end, rebarColor.getHex(), 0.1, 0.3);

         });
         function createCustomArrow(start, end, color, thickness = 0.1, coneSize = 0.3) {
            const arrowGroup = new THREE.Group();
        
            // Convert start and end to Vector3
            const startVec = new THREE.Vector3(...start);
            const endVec = new THREE.Vector3(...end);
        
            // Compute direction and length
            const direction = new THREE.Vector3().subVectors(endVec, startVec);
            const length = direction.length();
            direction.normalize();
        
            // Create cylinder for the shaft
            const shaftGeometry = new THREE.CylinderGeometry(thickness, thickness, length - coneSize, 12);
            const shaftMaterial = new THREE.MeshBasicMaterial({ color: color });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
        
            // Align the shaft along the Z-axis
            shaft.position.set(0, 0, (length - coneSize) / 2);
            shaft.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction); // Align to direction
        
            // Create cone for the arrowhead
            const coneGeometry = new THREE.ConeGeometry(coneSize * 1.5, coneSize, 12);
            const coneMaterial = new THREE.MeshBasicMaterial({ color: color });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
        
            // Position and rotate the cone
            cone.position.set(0, 0, length - coneSize / 2);
            cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction); // Align to direction
        
            // Add shaft and cone to arrow group
            arrowGroup.add(shaft);
            arrowGroup.add(cone);
        
            // Position the entire arrow
            arrowGroup.position.copy(startVec);
            arrowGroup.lookAt(endVec);
        
            scene.add(arrowGroup);
            return arrowGroup;
        }
        
    }

    //Shift plus middle mouse button to rotate
    setupResultsControls(){
        console.log("Setting up results controls...");
        // Remove mouse interactions setup
        console.log(controls)
        if (typeof SceneFunctions !== 'undefined' && SceneFunctions.setupMouseInteractions) {
            delete SceneFunctions.setupMouseInteractions;
        }
        
        // Re-enable orbit controls rotation and panning
        if (typeof controls !== 'undefined') {
            controls.enableRotate = true;
            controls.enablePan = true;
            
            // Assign default controls
            // controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE; // Right mouse rotates
            controls.mouseButtons.MIDDLE = THREE.MOUSE.PAN;   // Middle mouse pans
    
            // Assign Shift + Middle Mouse Button to Rotate
            controls.keys = { SHIFT: THREE.MOUSE.ROTATE };
    
            console.log(controls);
        }

        // Modify .selectBox CSS to be invisible
        const style = document.createElement('style');
        style.innerHTML = `
            .selectBox {
                border: none !important;
                background-color: transparent !important;
                position: fixed !important;
            }
        `;
        document.head.appendChild(style);
    }
}

