// This is the base polygon shape from which all analysis will be complete.
// There can be two types of constructors, one with a list of points and one with a given curve loop. A material is required for both conditions.
// If the point constructor is specified, a threejs shape will be created with straight lines connecting all the given points. This three js shape is saved as ConcShape.baseshape
// If the curve loop constructor is specified, a threejs shape will be created directly from the given curve loop. This three js shape is saved as ConcShape.baseshape
// There is an optional input for any holes
// There is a property within concShape called, mesh, which will store all of the internal meshing points and triangles generated by concAnlaysis.
// This class will also have a sub property called results. In results, we need to store angle and a list of triple data, [P, Mx, My]
// a separte class called "concAnalysis" will act on this base class and write in the results to the concShape.results properties.
// mesh is the base mesh, base shape with holes.
// FEMMesh is the deluany triangle mesh store base data in the X and Y coordinates. We will need to create U and V representations of this data
// for all Neutral axis angles.

import * as THREE from 'three';
import Delaunator from 'delaunator';
import { scene } from "./main.js"; 

export class ConcShape {
    constructor(input, material, holes = []) {
        this.material = material;
        this.holes = holes;
        this.mesh = null; // base polygon with any holes
        this.FEMmesh = []; // âœ… Stores the FEM triangular elements
        this.results = { angle: 0, data: [] }; // To store analysis results [P, Mx, My]
        this.transformedFEMcentroids = {}; // âœ… Initialize as an empty object
        this.transformedRebarcentriods = {angle: 0, data: []} // Stores transformed coordinates at a given angle, in the UV space
        this.basePolyXY = []; // âœ… Stores exterior polygon points
        this.holesPolyXY = []; // âœ… Stores hole points
        this.FEMarea = 0;  // âœ… Total FEM area
        this.centroidX = 0; // âœ… X coordinate of centroid
        this.centroidY = 0; // âœ… Y coordinate of centroid
        
        if (Array.isArray(input)) {
            // If input is an array of points
            this.basePoints = input;
            this.baseshape = this.createShapeFromPoints(input);
        } else if (input instanceof THREE.Shape) {
            // If input is a predefined curve loop (THREE.Shape)
            this.baseshape = input;
        } else {
            throw new Error("Invalid input: Must be an array of points or a THREE.Shape");
        }
        // âœ… Apply existing holes (if any)
        this.holes.forEach(hole => this.baseshape.holes.push(hole));
    }

    addHole(holePoints) {
        const hole = this.createShapeFromPoints(holePoints);
        this.holes.push(hole);
        this.baseshape.holes.push(hole); // âœ… Add hole to the main shape
        this.generateMesh();
    }

    createShapeFromPoints(points) {
        const shape = new THREE.Shape();
        if (points.length === 0) return shape;
        
        // Move to first point
        const firstPoint = new THREE.Vector2(points[0].x, points[0].y);
        shape.moveTo(firstPoint.x, firstPoint.y);
        
        // Connect remaining points with lines
        for (let i = 1; i < points.length; i++) {
            shape.lineTo(points[i].x, points[i].y);
        }
        
        // Close the shape
        shape.lineTo(firstPoint.x, firstPoint.y);
        
        // Add holes if provided
        this.holes.forEach(hole => shape.holes.push(hole));
        
        return shape;
    }

    generateMesh() {
        if (!this.baseshape) return;
        const geometry = new THREE.ShapeGeometry(this.baseshape);
        const meshMaterial = new THREE.MeshStandardMaterial({ color: 0xE5E5E5, transparent: true, opacity: 0.4 });
        this.mesh = new THREE.Mesh(geometry, meshMaterial);
        this.mesh.userData.concShape = this; // âœ… Store ConcShape instance in the mesh
    }

    generateFEMMesh() {
        if (!this.mesh) {
            console.error("Mesh does not exist for ConcShape.");
            return;
        }

        this.mesh.geometry.computeBoundingSphere();
        let center = [
            this.mesh.geometry.boundingSphere.center.x,
            this.mesh.geometry.boundingSphere.center.y
        ];
        let radius = this.mesh.geometry.boundingSphere.radius;

        // âœ… Store exterior polygon and holes in class properties
        let baseShape = this.mesh.geometry.parameters.shapes;
        this.basePolyXY = baseShape.curves.map(curve => [curve.v1.x, curve.v1.y]); 
        this.holesPolyXY = baseShape.holes.map(hole => 
            hole.curves.map(curve => [curve.v1.x, curve.v1.y])
        );


        let minSize = parseFloat(document.getElementById("intSpa").value);
        let edgeSize = parseFloat(document.getElementById("edgeSpa").value);

        // Generate interior and boundary points
        let createdPnts = this.generateCirclePnts(center, radius, minSize);
        let [boundaryPnts, holePnts] = this.generateBoundaryPnts(this.basePolyXY, this.holesPolyXY, edgeSize);
        let generatedPnts = [];
        for (let circlePnt of createdPnts) {
            let TF = this.rayCasting(circlePnt);
            if (TF[0] === true) {
                generatedPnts.push(circlePnt);
            }
        }

        // Generate Delaunay triangulation points
        let XYlist = this.generateDelaunayPoints(boundaryPnts, holePnts, generatedPnts);
        let delaunay = Delaunator.from(XYlist);

        // Generate triangles and mesh elements
        let triangleXY = this.drawTriangles(delaunay.triangles, XYlist);
        let concElements = this.drawTrianglesThree(triangleXY);

        this.FEMmesh = concElements; // âœ… Store generated FEM mesh
        console.log(this)
    }
     /** âœ… Updated rayCasting to use stored class properties */
     rayCasting(point) {
        if (!this.basePolyXY.length) {
            console.error("rayCasting Error: basePolyXY is empty", this.basePolyXY);
            return [false, 0, 0];
        }

        let n = this.basePolyXY.length;
        let count = 0;
        let holeCount = 0;
        let [x, y] = point;

        for (let i = 0; i < n; ++i) {
            let x1 = this.basePolyXY[i][0], y1 = this.basePolyXY[i][1];
            let x2 = this.basePolyXY[(i + 1) % n][0], y2 = this.basePolyXY[(i + 1) % n][1];

            if (y < y1 !== y < y2 && x < ((x2 - x1) * (y - y1)) / (y2 - y1) + x1) {
                count += 1;
            }
        }

        for (let holePoly of this.holesPolyXY) {
            if (!holePoly.length) continue; // âœ… Skip empty holes

            let nHole = holePoly.length;
            for (let i = 0; i < nHole; ++i) {
                let x1 = holePoly[i][0], y1 = holePoly[i][1];
                let x2 = holePoly[(i + 1) % nHole][0], y2 = holePoly[(i + 1) % nHole][1];

                if (y < y1 !== y < y2 && x < ((x2 - x1) * (y - y1)) / (y2 - y1) + x1) {
                    holeCount += 1;
                }
            }
        }

        return [(count + holeCount) % 2 !== 0, count, holeCount];
    }
    generateCirclePnts(center, radius, minSize) {
        let nCircles = Math.round(radius / minSize);
        let stepSize = radius / nCircles;
        let createdPnts = [[center[0], center[1]]];

        for (let i = 0; i < nCircles; i++) {
            let tempRadius = (i + 1) * stepSize;
            let totalLength = Math.PI * 2 * tempRadius;
            let nPoints = Math.round(totalLength / minSize);
            let thetaStep = (2 * Math.PI) / nPoints;

            for (let j = 0; j < nPoints; j++) {
                createdPnts.push([
                    Math.cos(thetaStep * j) * tempRadius + center[0],
                    Math.sin(thetaStep * j) * tempRadius + center[1]
                ]);
            }
        }
        return createdPnts;
    }
    generateBoundaryPnts(boundary, holes, minSize) {
        let boundaryPnts = this.generateEdgePnts(boundary, minSize);
        let holePnts = holes.map(hole => this.generateEdgePnts(hole, minSize)).flat();
        return [boundaryPnts, holePnts];
    }

    generateEdgePnts(edge, minSize) {
        let edgePnts = [];
        for (let i = 0; i < edge.length; i++) {
            let nextIndex = (i + 1) % edge.length;
            let [x1, y1] = edge[i];
            let [x2, y2] = edge[nextIndex];

            let length = Math.hypot(x2 - x1, y2 - y1);
            let nPoints = Math.round(length / minSize);
            let step = length / nPoints;
            let vector = [(x2 - x1) / length, (y2 - y1) / length];

            for (let j = 0; j < nPoints; j++) {
                edgePnts.push([x1 + vector[0] * j * step, y1 + vector[1] * j * step]);
            }
        }
        return edgePnts;
    }

    generateDelaunayPoints(boundaryPnts, holePnts, generatedPnts) {
        return [...boundaryPnts, ...holePnts, ...generatedPnts];
    }

    drawTriangles(triangles, XYlist) {
        return triangles.reduce((acc, _, i) => {
            if (i % 3 === 0) {
                acc.push([
                    XYlist[triangles[i]],
                    XYlist[triangles[i + 1]],
                    XYlist[triangles[i + 2]]
                ]);
            }
            return acc;
        }, []);
    }

    drawTrianglesThree(positionTri) {
        if (!scene || typeof scene.add !== "function") {
            console.error("Scene is not defined or is not a valid Three.js scene.");
            return [];
        }

        let concElements = [];
        this.FEMarea = 0; // âœ… Reset total area
        this.centroidX = 0; // âœ… Reset centroidX
        this.centroidY = 0; // âœ… Reset centroidY

        for (let tri of positionTri) {
            let geometry = new THREE.BufferGeometry();
            let vertices = new Float32Array(tri.flatMap(([x, y]) => [x, y, 0]));
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

            let material = new THREE.MeshStandardMaterial({ wireframe: true });
            let mesh = new THREE.Mesh(geometry, material);
            mesh.area = Math.abs(
                (tri[0][0] * tri[1][1] + tri[1][0] * tri[2][1] + tri[2][0] * tri[0][1]) - 
                (tri[0][1] * tri[1][0] + tri[1][1] * tri[2][0] + tri[2][1] * tri[0][0])
            ) / 2;

            mesh.centroid = {
                x: (tri[0][0] + tri[1][0] + tri[2][0]) / 3,
                y: (tri[0][1] + tri[1][1] + tri[2][1]) / 3
            };

            // âœ… Use stored basePolyXY and holesPolyXY for ray casting
            if (this.rayCasting([mesh.centroid.x, mesh.centroid.y])[0]) {
                scene.add(mesh);
                concElements.push(mesh);

                // âœ… Update FEMarea and centroid
                this.FEMarea += mesh.area;
                this.centroidX += mesh.area * mesh.centroid.x;
                this.centroidY += mesh.area * mesh.centroid.y;
            }
        }

        // âœ… Compute final centroid
        if (this.FEMarea > 0) {
            this.centroidX /= this.FEMarea;
            this.centroidY /= this.FEMarea;
        } else {
            console.warn("Total FEM area is zero, cannot compute centroid.");
        }

        return concElements;
    }

    // /**
    //  * âœ… Transforms the centroids of the FEMmesh into the U-V coordinate system at a given angle Î¸.
    //  * @param {number} angle - Rotation angle in **degrees**
    //  */
    // transformCoordinatesAtAngle(angle) {
    //     if (!this.FEMmesh || this.FEMmesh.length === 0) {
    //         console.error("âŒ FEM mesh is empty, cannot transform coordinates.");
    //         return;
    //     }
    
    //     // âœ… Ensure transformedFEMcentroids is initialized
    //     if (!this.transformedFEMcentroids) {
    //         this.transformedFEMcentroids = {}; 
    //     }
    
    //     const radians = (Math.PI / 180) * angle; // Convert degrees to radians
    //     const cosTheta = Math.cos(radians);
    //     const sinTheta = Math.sin(radians);
    
    //     let transformedPoints = this.FEMmesh.map(mesh => {
    //         let u = cosTheta * (mesh.centroid.x - this.centroidX) + sinTheta * (mesh.centroid.y - this.centroidY);
    //         let v = -sinTheta * (mesh.centroid.x - this.centroidX) + cosTheta * (mesh.centroid.y - this.centroidY);
    //         return [u, v];
    //     });
    
    //     // âœ… Store the transformed points in the dictionary
    //     this.transformedFEMcentroids[angle] = transformedPoints;
    
    //     console.log(`âœ… Transformed FEM centroids at ${angle}Â° stored successfully.`);
    // }
    transformCoordinatesAtAngle(angle, allSelectedRebar) {
        if (!this.FEMmesh || this.FEMmesh.length === 0) {
            console.error("âŒ FEM mesh is empty, cannot transform coordinates.");
            return;
        }
    
        if (!this.transformedFEMcentroids) {
            this.transformedFEMcentroids = {};
        }
    
        const radians = (Math.PI / 180) * angle; // Convert degrees to radians
        const cosTheta = Math.cos(radians);
        const sinTheta = Math.sin(radians);
    
        // âœ… Transform Concrete Centroids
        let transformedConcrete = this.FEMmesh.map(mesh => {
            let u = cosTheta * (mesh.centroid.x - this.centroidX) + sinTheta * (mesh.centroid.y - this.centroidY);
            let v = -sinTheta * (mesh.centroid.x - this.centroidX) + cosTheta * (mesh.centroid.y - this.centroidY);
            return { u, v };
        });
    
        // âœ… Transform Rebar Centroids
        console.log("YOUR SELECTED REBAR IS THE FOLLOWING")
        console.log(allSelectedRebar)
        let transformedRebar = allSelectedRebar.map(rebar => {
            let u = cosTheta * (rebar.position.x - this.centroidX) + sinTheta * (rebar.position.y - this.centroidY);
            let v = -sinTheta * (rebar.position.x - this.centroidX) + cosTheta * (rebar.position.y - this.centroidY);
            return { u, v };
        });
    
        // âœ… Store both transformed concrete and rebar data
        this.transformedFEMcentroids[angle] = {
            angle: angle,
            conc: transformedConcrete,  // âœ… Store concrete mesh UV data
            rebar: transformedRebar     // âœ… Store rebar UV data
        };
    
        // âœ… Log the min/max U and V values
        const allUV = [...transformedConcrete, ...transformedRebar];
        const uVals = allUV.map(p => p.u);
        const vVals = allUV.map(p => p.v);
        
        console.log(`âœ… Transformed FEM centroids at ${angle}Â° stored successfully.`);
        console.log(`ðŸ”¹ Min U: ${Math.min(...uVals)}, Max U: ${Math.max(...uVals)}`);
        console.log(`ðŸ”¹ Min V: ${Math.min(...vVals)}, Max V: ${Math.max(...vVals)}`);
    }
}

