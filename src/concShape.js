// This is the base polygon shape from which all analysis will be complete.
// There can be two types of constructors, one with a list of points and one with a given curve loop. A material is required for both conditions.
// If the point constructor is specified, a threejs shape will be created with straight lines connecting all the given points. This three js shape is saved as ConcShape.baseshape
// If the curve loop constructor is specified, a threejs shape will be created directly from the given curve loop. This three js shape is saved as ConcShape.baseshape
// There is an optional input for any holes
// There is a property within concShape called, mesh, which will store all of the internal meshing points and triangles generated by concAnlaysis.
// This class will also have a sub property called results. In results, we need to store angle and a list of triple data, [P, Mx, My]
// a separte class called "concAnalysis" will act on this base class and write in the results to the concShape.results properties.
// mesh is the base mesh, base shape with holes.
// FEMMesh is the deluany triangle mesh store base data in the X and Y coordinates. We will need to create U and V representations of this data
// for all Neutral axis angles.

import * as THREE from 'three';
import Delaunator from 'delaunator';
import { scene } from "./main.js"; 
import { rebarDia } from './threeJSscenefunctions.js';
import Plotly from 'plotly.js-dist-min';


export class ConcShape {
    constructor(input, material, holes = []) {
        this.material = material;
        this.holes = holes;
        this.mesh = null; // base polygon with any holes
        this.FEMmesh = []; // ‚úÖ Stores the FEM triangular elements
        this.PMMresults = { }; // To store analysis results {angle: [P, Mu, Mv]}
        this.transformedFEMcentroids = {}; // ‚úÖ Initialize as an empty object
        

        this.basePolyXY = []; // ‚úÖ Stores exterior polygon points
        this.holesPolyXY = []; // ‚úÖ Stores hole points
        this.FEMarea = 0;  // ‚úÖ Total FEM area
        this.centroidX = 0; // ‚úÖ X coordinate of centroid
        this.centroidY = 0; // ‚úÖ Y coordinate of centroid
        this.strainProfiles = {} //This will store all of the strain profiles for a given NA angle

        this.rebarObjects = [] // ‚úÖ Initialize rebarObjects on creation
        
        if (Array.isArray(input)) {
            // If input is an array of points
            this.basePoints = input;
            this.baseshape = this.createShapeFromPoints(input);
        } else if (input instanceof THREE.Shape) {
            // If input is a predefined curve loop (THREE.Shape)
            this.baseshape = input;
        } else {
            throw new Error("Invalid input: Must be an array of points or a THREE.Shape");
        }
        // ‚úÖ Apply existing holes (if any)
        this.holes.forEach(hole => this.baseshape.holes.push(hole));
    }

    // ‚úÖ Stores Three.js Points objects directly
    initializeRebarObjects(allSelectedRebar) {
        this.rebarObjects = allSelectedRebar; // Store Three.js Points directly
    }


    addHole(holePoints) {
        const hole = this.createShapeFromPoints(holePoints);
        this.holes.push(hole);
        this.baseshape.holes.push(hole); // ‚úÖ Add hole to the main shape
        this.generateMesh();
    }

    createShapeFromPoints(points) {
        const shape = new THREE.Shape();
        if (points.length === 0) return shape;
        
        // Move to first point
        const firstPoint = new THREE.Vector2(points[0].x, points[0].y);
        shape.moveTo(firstPoint.x, firstPoint.y);
        
        // Connect remaining points with lines
        for (let i = 1; i < points.length; i++) {
            shape.lineTo(points[i].x, points[i].y);
        }
        
        // Close the shape
        shape.lineTo(firstPoint.x, firstPoint.y);
        
        // Add holes if provided
        this.holes.forEach(hole => shape.holes.push(hole));
        
        return shape;
    }

    generateMesh() {
        if (!this.baseshape) return;
        const geometry = new THREE.ShapeGeometry(this.baseshape);
        const meshMaterial = new THREE.MeshStandardMaterial({ color: 0xE5E5E5, transparent: true, opacity: 0.4 });
        this.mesh = new THREE.Mesh(geometry, meshMaterial);
        this.mesh.userData.concShape = this; // ‚úÖ Store ConcShape instance in the mesh
    }

    generateFEMMesh() {
        if (!this.mesh) {
            console.error("Mesh does not exist for ConcShape.");
            return;
        }

        this.mesh.geometry.computeBoundingSphere();
        let center = [
            this.mesh.geometry.boundingSphere.center.x,
            this.mesh.geometry.boundingSphere.center.y
        ];
        let radius = this.mesh.geometry.boundingSphere.radius;

        // ‚úÖ Store exterior polygon and holes in class properties
        let baseShape = this.mesh.geometry.parameters.shapes;
        this.basePolyXY = baseShape.curves.map(curve => [curve.v1.x, curve.v1.y]); 
        this.holesPolyXY = baseShape.holes.map(hole => 
            hole.curves.map(curve => [curve.v1.x, curve.v1.y])
        );


        let minSize = parseFloat(document.getElementById("intSpa").value);
        let edgeSize = parseFloat(document.getElementById("edgeSpa").value);

        // Generate interior and boundary points
        let createdPnts = this.generateCirclePnts(center, radius, minSize);
        let [boundaryPnts, holePnts] = this.generateBoundaryPnts(this.basePolyXY, this.holesPolyXY, edgeSize);
        let generatedPnts = [];
        for (let circlePnt of createdPnts) {
            let TF = this.rayCasting(circlePnt);
            if (TF[0] === true) {
                generatedPnts.push(circlePnt);
            }
        }

        // Generate Delaunay triangulation points
        let XYlist = this.generateDelaunayPoints(boundaryPnts, holePnts, generatedPnts);
        let delaunay = Delaunator.from(XYlist);

        // Generate triangles and mesh elements
        let triangleXY = this.drawTriangles(delaunay.triangles, XYlist);
        let concElements = this.drawTrianglesThree(triangleXY);

        this.FEMmesh = concElements; // ‚úÖ Store generated FEM mesh
        console.log(this)
    }
     /** ‚úÖ Updated rayCasting to use stored class properties */
     rayCasting(point) {
        if (!this.basePolyXY.length) {
            console.error("rayCasting Error: basePolyXY is empty", this.basePolyXY);
            return [false, 0, 0];
        }

        let n = this.basePolyXY.length;
        let count = 0;
        let holeCount = 0;
        let [x, y] = point;

        for (let i = 0; i < n; ++i) {
            let x1 = this.basePolyXY[i][0], y1 = this.basePolyXY[i][1];
            let x2 = this.basePolyXY[(i + 1) % n][0], y2 = this.basePolyXY[(i + 1) % n][1];

            if (y < y1 !== y < y2 && x < ((x2 - x1) * (y - y1)) / (y2 - y1) + x1) {
                count += 1;
            }
        }

        for (let holePoly of this.holesPolyXY) {
            if (!holePoly.length) continue; // ‚úÖ Skip empty holes

            let nHole = holePoly.length;
            for (let i = 0; i < nHole; ++i) {
                let x1 = holePoly[i][0], y1 = holePoly[i][1];
                let x2 = holePoly[(i + 1) % nHole][0], y2 = holePoly[(i + 1) % nHole][1];

                if (y < y1 !== y < y2 && x < ((x2 - x1) * (y - y1)) / (y2 - y1) + x1) {
                    holeCount += 1;
                }
            }
        }

        return [(count + holeCount) % 2 !== 0, count, holeCount];
    }
    generateCirclePnts(center, radius, minSize) {
        let nCircles = Math.round(radius / minSize);
        let stepSize = radius / nCircles;
        let createdPnts = [[center[0], center[1]]];

        for (let i = 0; i < nCircles; i++) {
            let tempRadius = (i + 1) * stepSize;
            let totalLength = Math.PI * 2 * tempRadius;
            let nPoints = Math.round(totalLength / minSize);
            let thetaStep = (2 * Math.PI) / nPoints;

            for (let j = 0; j < nPoints; j++) {
                createdPnts.push([
                    Math.cos(thetaStep * j) * tempRadius + center[0],
                    Math.sin(thetaStep * j) * tempRadius + center[1]
                ]);
            }
        }
        return createdPnts;
    }
    generateBoundaryPnts(boundary, holes, minSize) {
        let boundaryPnts = this.generateEdgePnts(boundary, minSize);
        let holePnts = holes.map(hole => this.generateEdgePnts(hole, minSize)).flat();
        return [boundaryPnts, holePnts];
    }

    generateEdgePnts(edge, minSize) {
        let edgePnts = [];
        for (let i = 0; i < edge.length; i++) {
            let nextIndex = (i + 1) % edge.length;
            let [x1, y1] = edge[i];
            let [x2, y2] = edge[nextIndex];

            let length = Math.hypot(x2 - x1, y2 - y1);
            let nPoints = Math.round(length / minSize);
            let step = length / nPoints;
            let vector = [(x2 - x1) / length, (y2 - y1) / length];

            for (let j = 0; j < nPoints; j++) {
                edgePnts.push([x1 + vector[0] * j * step, y1 + vector[1] * j * step]);
            }
        }
        return edgePnts;
    }

    generateDelaunayPoints(boundaryPnts, holePnts, generatedPnts) {
        return [...boundaryPnts, ...holePnts, ...generatedPnts];
    }

    drawTriangles(triangles, XYlist) {
        return triangles.reduce((acc, _, i) => {
            if (i % 3 === 0) {
                acc.push([
                    XYlist[triangles[i]],
                    XYlist[triangles[i + 1]],
                    XYlist[triangles[i + 2]]
                ]);
            }
            return acc;
        }, []);
    }

    drawTrianglesThree(positionTri) {
        if (!scene || typeof scene.add !== "function") {
            console.error("Scene is not defined or is not a valid Three.js scene.");
            return [];
        }

        let concElements = [];
        this.FEMarea = 0; // ‚úÖ Reset total area
        this.centroidX = 0; // ‚úÖ Reset centroidX
        this.centroidY = 0; // ‚úÖ Reset centroidY

        for (let tri of positionTri) {
            let geometry = new THREE.BufferGeometry();
            let vertices = new Float32Array(tri.flatMap(([x, y]) => [x, y, 0]));
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

            let material = new THREE.MeshStandardMaterial({ wireframe: true });
            let mesh = new THREE.Mesh(geometry, material);
            mesh.area = Math.abs(
                (tri[0][0] * tri[1][1] + tri[1][0] * tri[2][1] + tri[2][0] * tri[0][1]) - 
                (tri[0][1] * tri[1][0] + tri[1][1] * tri[2][0] + tri[2][1] * tri[0][0])
            ) / 2;

            mesh.centroid = {
                x: (tri[0][0] + tri[1][0] + tri[2][0]) / 3,
                y: (tri[0][1] + tri[1][1] + tri[2][1]) / 3
            };

            // ‚úÖ Use stored basePolyXY and holesPolyXY for ray casting
            if (this.rayCasting([mesh.centroid.x, mesh.centroid.y])[0]) {
                scene.add(mesh);
                concElements.push(mesh);

                // ‚úÖ Update FEMarea and centroid
                this.FEMarea += mesh.area;
                this.centroidX += mesh.area * mesh.centroid.x;
                this.centroidY += mesh.area * mesh.centroid.y;
            }
        }

        // ‚úÖ Compute final centroid
        if (this.FEMarea > 0) {
            this.centroidX /= this.FEMarea;
            this.centroidY /= this.FEMarea;
        } else {
            console.warn("Total FEM area is zero, cannot compute centroid.");
        }

        return concElements;
    }

    //This data will be orgainzed the following way. this.transformedFEMcentroids[45]; will return results at 45 degrees.
    // {
    //     45: {  // üîπ Angle (key)
    //         angle: 45,  // üîπ The transformation angle
    //         conc: [  // üîπ Transformed concrete FEM mesh centroids (U, V)
    //             { u: 1.5, v: 3.2 },
    //             { u: -2.1, v: 4.0 },
    //         ],
    //         rebar: [  // üîπ Transformed rebar centroids (U, V)
    //             { u: -3.2, v: 5.5 },
    //             { u: 4.8, v: -1.2 }
    //         ]
    //         centroidCoordinates : { "u": 0, "v": 0 }
    //     },

    //     90: {  // üîπ Another transformation at 90 degrees
    //         angle: 90,
    //         conc: [
    //             { u: 3.2, v: -1.5 },
    //             { u: 4.0, v: 2.1 },
    //         ],
    //         rebar: [
    //             { u: 5.5, v: 3.2 },
    //             { u: -1.2, v: -4.8 }
    //         ]
    //         centroidCoordinates : { u: 0, v: 0 }
    //     }
    // }

    // ‚úÖ Transforms coordinates at a given angle
    transformCoordinatesAtAngle(angle) {
        if (!this.FEMmesh || this.FEMmesh.length === 0) {
            console.error("‚ùå FEM mesh is empty, cannot transform coordinates.");
            return;
        }

        if (!this.transformedFEMcentroids) {
            this.transformedFEMcentroids = {};
        }

        const radians = (Math.PI / 180) * angle; // Convert degrees to radians
        const cosTheta = Math.cos(radians);
        const sinTheta = Math.sin(radians);

        // ‚úÖ Transform Concrete Centroids
        let transformedConcrete = this.FEMmesh.map(mesh => {
            let u = cosTheta * (mesh.centroid.x - this.centroidX) + sinTheta * (mesh.centroid.y - this.centroidY);
            let v = -sinTheta * (mesh.centroid.x - this.centroidX) + cosTheta * (mesh.centroid.y - this.centroidY);
            return { u, v };
        });

        // ‚úÖ Transform Rebar Centroids (Stored in `rebarObjects`)
        let transformedRebar = this.rebarObjects.map(rebar => {
            let rebarX = rebar.geometry.attributes.position.array[0]
            let rebarY = rebar.geometry.attributes.position.array[1]
 
            let u = cosTheta * (rebarX - this.centroidX) + sinTheta * (rebarY - this.centroidY);
            let v = -sinTheta * (rebarX - this.centroidX) + cosTheta * (rebarY - this.centroidY);
            
            // ‚úÖ Store transformed coordinates inside the rebar object
            if (!rebar.transformed) rebar.transformed = {}; // Ensure dictionary exists
            rebar.transformed[angle] = { u, v };

            return { u, v };
        });

        // ‚úÖ Transform Centroid Coordinates
        let transformedCentroid = {
            u: cosTheta * (this.centroidX - this.centroidX) + sinTheta * (this.centroidY - this.centroidY),
            v: -sinTheta * (this.centroidX - this.centroidX) + cosTheta * (this.centroidY - this.centroidY)
        };

        // ‚úÖ Store transformed data in the dictionary
        this.transformedFEMcentroids[angle] = {
            angle: angle,
            conc: transformedConcrete,         // ‚úÖ Store concrete mesh UV data
            rebar: this.rebarObjects,          // ‚úÖ Store rebar objects with UV data
            centroidCoordinates: transformedCentroid  // ‚úÖ Store transformed centroid
        };

        // ‚úÖ Log the min/max U and V values
        const allUV = [...transformedConcrete, ...this.rebarObjects.map(rebar => rebar.transformed[angle])];
        const uVals = allUV.map(p => p.u);
        const vVals = allUV.map(p => p.v);

        console.log(`‚úÖ Transformed FEM centroids at ${angle}¬∞ stored successfully.`);
        console.log(`üîπ Min U: ${Math.min(...uVals)}, Max U: ${Math.max(...uVals)}`);
        console.log(`üîπ Min V: ${Math.min(...vVals)}, Max V: ${Math.max(...vVals)}`);
        console.log(`üéØ Transformed Centroid at ${angle}¬∞: U=${transformedCentroid.u}, V=${transformedCentroid.v}`);
    }

    // Generate Strain Profiles for the PMM Analysis, returns [m and b] of y = mx +b linear strain equation
    generateStrains(angle) {
        // ‚úÖ Ensure the transformed FEM centroids exist for the given angle
        if (!this.transformedFEMcentroids[angle]) {
            console.error(`‚ùå No transformed FEM centroids found for angle ${angle}`);
            return;
        }

        // ‚úÖ Extract transformed rebar and concrete locations
        let concLocations = this.transformedFEMcentroids[angle].conc.map(p => p.v);  // Get only V coordinates

        // ‚úÖ Extract transformed rebar V coordinates
        let rebarLocations = this.rebarObjects
        .map(rebar => rebar.transformed[angle]?.v) // ‚úÖ Access transformed V values
        .filter(v => v !== undefined); // ‚úÖ Filter out undefined values

        if (!rebarLocations.length || !concLocations.length) {
            console.error("‚ùå Rebar or Concrete locations are empty. Cannot generate strain profiles.");
            return;
        }

        // ‚úÖ Find min/max V positions for rebar and concrete
        let rebarMax = Math.max(...rebarLocations);
        let rebarMin = Math.min(...rebarLocations);
        let concMax = Math.max(...concLocations);
        let concMin = Math.min(...concLocations);

        console.log(`üîπ Angle ${angle}¬∞:`);
        console.log(`   ‚úÖ Rebar Max: ${rebarMax}, Min: ${rebarMin}`);
        console.log(`   ‚úÖ Concrete Max: ${concMax}, Min: ${concMin}`);

        // ‚úÖ Define strain limits
        let epsilon_c = -0.003;  // Concrete crushing strain
        let epsilon_t = 0.025;   // Maximum tension strain
        let steps = 25;          // Number of steps for profile generation

        // ‚úÖ Initialize strain profiles
        let strainProfileCtoT = [];
        let strainProfileTtoT = [];
        let strainProfileTtoC = [];
        let strainProfileCtoC = [];

        // ‚úÖ Compute slope steps
        let slopeStepCtoT = ((epsilon_t - epsilon_c) / (concMax - rebarMin)) / (steps - 1);
        let slopeStepTtoT = ((epsilon_c - epsilon_t) / (concMax - rebarMin)) / (steps - 1);
        let slopeStepTtoC = -((epsilon_c - epsilon_t) / (rebarMax - concMin)) / (steps - 1);
        let slopeStepCtoC = -((epsilon_c - epsilon_t) / (rebarMax - concMin)) / (steps - 1);

        // ‚úÖ Generate strain profiles
        for (let i = 0; i < steps; i++) {
            // ‚úÖ Compression to Tension (C to T)
            strainProfileCtoT.push([
                -i * slopeStepCtoT, 
                epsilon_c - (-i * slopeStepCtoT) * concMax
            ]);

            // ‚úÖ Tension Failure to Tension (T to T)
            strainProfileTtoT.push([
                -(epsilon_t - epsilon_c) / (concMax - rebarMin) - slopeStepTtoT * i,
                epsilon_t - (-(epsilon_t - epsilon_c) / (concMax - rebarMin) - slopeStepTtoT * i) * rebarMin
            ]);

            // ‚úÖ Tension to Compression (T to C)
            strainProfileTtoC.push([
                slopeStepTtoC * i,
                epsilon_t - (i * slopeStepTtoC) * rebarMax
            ]);

            // ‚úÖ Compression to Compression (C to C)
            strainProfileCtoC.push([
                -((epsilon_c - epsilon_t) / (rebarMax - concMin)) - slopeStepCtoC * i,
                epsilon_c - slopeStepCtoC * -(steps - 1 - i) * -concMin
            ]);
        }

        // ‚úÖ Combine all strain profiles
        let strainProfile = strainProfileCtoT.concat(strainProfileTtoT, strainProfileTtoC, strainProfileCtoC);

        console.log(`‚úÖ Generated strain profile for angle ${angle}:`, strainProfile);

        // ‚úÖ Store strain profile in the class dictionary
        if (!this.strainProfiles) {
            this.strainProfiles = {}; 
        }
        this.strainProfiles[angle] = strainProfile;

        return strainProfile;
    }

    //assumes a linear strain distribution
    strainFunction(m, x, b) {
        return m*x+b
    }
  
    // Given the angle, generate the associated P, Mu, Mv.
    generatePMM(angle) {
        if (!this.transformedFEMcentroids[angle]) {
            console.error(`‚ùå No transformed centroids found for angle ${angle}`);
            return;
        }
        
        if (!this.strainProfiles[angle]) {
            console.error(`‚ùå No strain profiles found for angle ${angle}`);
            return;
        }
    
    
        console.log(`üîπ Generating PMM for angle ${angle}¬∞...`);
    
        let totalAxialForceArray = []
        let totalMomentUArray = []
        let totalMomentVArray = []

        // Retrieve centroid coordinates in U-V space
        let centroidU = this.transformedFEMcentroids[angle].centroidCoordinates.u;
        let centroidV = this.transformedFEMcentroids[angle].centroidCoordinates.v;

        // Get material properties
        let concMaterial = this.material;  // ‚úÖ Concrete material stored in class

        // ‚úÖ Ensure PMM dictionary exists
        if (!this.PMMresults) {
            this.PMMresults = {};
        }

        // ‚úÖ Ensure the angle entry exists in PMMresults
        if (!this.PMMresults[angle]) {
            this.PMMresults[angle] = { P: [], Mu: [], Mv: [] };
        }
    
        //looping through each stress strain profile
        for (var strainProfile of this.strainProfiles[angle]) {
            let concForce = 0
            let concMomentV = 0
            let concMomentU = 0
            let steelForce = 0
            let steelMomentV = 0
            let steelMomentU = 0
    
    
            for (let i = 0; i < this.FEMmesh.length; i++) {
                let concEle = this.FEMmesh[i]; // Get the concrete element
                let transformedConc = this.transformedFEMcentroids[angle].conc[i]; // Get the transformed coordinates
            
                if (!transformedConc) {
                    console.warn(`‚ö†Ô∏è Missing transformed centroid for concrete element at index ${i}`);
                    continue;
                }
            
                // ‚úÖ Use transformed V coordinate
                let concStrain = this.strainFunction(strainProfile[0], transformedConc.v, strainProfile[1]);
                let nodalConcForce = concMaterial.stress(concStrain) * concEle.area;
            
                // ‚úÖ Debugging logs
                // console.log(concEle);
                // console.log(`Original V: ${concEle.centroid.v}, Transformed V: ${transformedConc.v}`);
            
                concForce += nodalConcForce;
                concMomentV += nodalConcForce * (centroidV - transformedConc.v);
                concMomentU += nodalConcForce * (centroidU - transformedConc.u);
            }
            
            for (let rebar of this.rebarObjects) {
                //area times stress(strain)
                let steelMaterial = rebar.materialData; // ‚úÖ Retrieve steel material
                let transformedRebar = rebar.transformed[angle]; // ‚úÖ Get transformed U/V at angle
                if (!transformedRebar) {
                    console.warn(`‚ö†Ô∏è No transformed coordinates for rebar at angle ${angle}`);
                    continue;
                }
    
                let rebarStrain = this.strainFunction(strainProfile[0], transformedRebar.v, strainProfile[1]);
                let nodalSteelForce = (Math.PI / 4) * rebarDia[rebar.rebarSize] ** 2 * steelMaterial.stress(rebarStrain);
                // console.log(rebarDia[rebar.rebarSize]) size is correct
                // console.log(steelMaterial) //Material is correct
                // console.log(rebarStrain) //strain appears correct
                // console.log(steelMaterial.stress(rebarStrain)) //stress appears correct

                steelForce += nodalSteelForce
                steelMomentV += nodalSteelForce*(centroidV-transformedRebar.v)
                steelMomentU += nodalSteelForce*(centroidU-transformedRebar.u)
            }
            console.log('your steel force is', steelForce)
            console.log('your conc force is', concForce)
            let resultForce=steelForce+concForce
            totalAxialForceArray.push(resultForce)
            totalMomentVArray.push((-steelMomentV-concMomentV)/12)
            totalMomentUArray.push((-steelMomentU-concMomentU)/12)
            }
        // ‚úÖ Store results in dictionary
        this.PMMresults[angle].P.push(totalAxialForceArray);
        this.PMMresults[angle].Mu.push(totalMomentUArray);
        this.PMMresults[angle].Mv.push(totalMomentVArray);

        console.log("PMM Results Data:", this.PMMresults);

    }

    plotPMMResults() {
        if (!this.PMMresults || Object.keys(this.PMMresults).length === 0) {
            console.error("‚ùå No PMM results available to plot.");
            return;
        }
    
        // Extract P, Mu, Mv from PMMresults dictionary
        let P_values = [];
        let Mu_values = [];
        let Mv_values = [];
        let angles = [];
    
        for (let angle in this.PMMresults) {
            P_values.push(...this.PMMresults[angle].P.flat());
            Mu_values.push(...this.PMMresults[angle].Mu.flat());
            Mv_values.push(...this.PMMresults[angle].Mv.flat());
            angles.push(...Array(this.PMMresults[angle].P.flat().length).fill(Number(angle))); // Store angles as numbers
        }
    
        console.log("your P values are", P_values);
        console.log("your Mu values are", Mu_values);
        console.log("your Mv values are", Mv_values);
        console.log("your angles are", angles);
    
        // Remove existing content and add a new div for Plotly
        let resultsDiv = document.getElementById("results");
        resultsDiv.innerHTML = "<h3>3D PMM Interaction Diagram</h3><div id='pmPlot' style='width: 100%; height: 500px;'></div>";
    
        // ‚úÖ Scatter Plot (Points)
        let scatterTrace = {
            x: Mu_values,
            y: Mv_values,
            z: P_values,
            mode: "markers",
            type: "scatter3d",
            marker: {
                size: 5,
                color: angles, // Color by angle
                colorscale: "Viridis",
                opacity: 0.8
            },
            name: "PMM Data"
        };
    
        // ‚úÖ Line Plot (Connecting the points)
        let lineTrace = {
            x: Mu_values,
            y: Mv_values,
            z: P_values,
            mode: "lines",
            type: "scatter3d",
            line: {
                color: "black",
                width: 2
            },
            name: "PMM Curve"
        };
    
        // ‚úÖ Find axis limits to make them equal
        let minVal = Math.min(...Mu_values, ...Mv_values, ...P_values);
        let maxVal = Math.max(...Mu_values, ...Mv_values, ...P_values);
    
        let layout = {
            title: "3D P-M Interaction Diagram",
            scene: {
                xaxis: { title: "Mu (kip-ft)", range: [minVal, maxVal] },
                yaxis: { title: "Mv (kip-ft)", range: [minVal, maxVal] },
                zaxis: { title: "P (kips)", range: [minVal, maxVal] },
                aspectmode: "cube" // ‚úÖ Forces equal scaling on all axes
            },
            margin: { l: 0, r: 0, b: 0, t: 50 }
        };
    
        // ‚úÖ Render the plot with both traces
        Plotly.newPlot("pmPlot", [scatterTrace, lineTrace], layout);
    }
}

